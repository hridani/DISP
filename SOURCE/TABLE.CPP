/*****************************************************************************/
/*                           S T R U C T   F I L E                                   */
/*----------------------------------------------------------------------------------------------*/
/*     Описание на функциите от клас STUCT FILE                      */
/*****************************************************************************/
/*==========Заглавни файлове=======================*/
#include <conio.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "..\include\table.h"
#include "..\include\memnew.h"
ListNode listnode;
/*********************************************************************/
/* ListNode::removeall:Изтриване (унищожаване) на списъка */
/* Вход  : Начало на списъка                                            */
/* Изход : Няма                                                                 */
/**********************************************************************/
void ListNode::removeall(NodeT **p)
{
  if(*p==NULL)
    return;
  removeall(&((*p)->next)); // Изтриване на наследниците 
  delete *p;                           // Изтриване на началото
  nb--;
  *p=NULL;
}

/*********************************************************************/
/* ListNode::find:Търсене на елемент от списъка                  */
/* Вход  : Ключ за търсене                                               */
/* Изход : Няма                                                                 */
/**********************************************************************/
void ListNode::find (unsigned number)
{ 
  if(*cur==NULL)    /* празен списък */
   return;
  if((*cur)->numb==number) /* проверка за номера */
    return;
  bcur=*cur;  /* указател към последния елемент */
  cur=&(*cur)->next; /* следващия */
  if(*cur)
  {
     if((*cur)->numb>number) /* проверка за номера на следващия */
       return;
  }
  find(number);  /* рекурсивно извикване */
}

/*********************************************************************/
/* ListNode::findnz:Търсене на елемент от списъка                  */
/* Вход  : Ключ за търсене                                               */
/* Изход : Няма                                                                 */
/**********************************************************************/
void ListNode::findnz (unsigned number)
{ 
  if(*cur==NULL)    /* празен списък */
   return;
  if((*cur)->numbnz==number) /* проверка за номера */
    return;
  bcur=*cur;  /* указател към последния елемент */
  cur=&(*cur)->next; /* следващия */
  if(*cur)
  {
     if((*cur)->numbnz>number) /* проверка за номера на следващия */
       return;
  }
  findnz(number);  /* рекурсивно извикване */
}

/*********************************************************************/
/* ListNode::add :Добавяне на възел със зададен номер      */
/* Вход  : номер на полето,вид на записа - еднотекстов или многотекстов */
/*             име на файла ,брой текстове при многотекстовите        */
/* Изход :Няма                                                                 */
/************************************************************************/
flag ListNode::add(unsigned nm,double  val,double mn,double mx,char * text)
{
  NodeT *temp;
  unsigned  nmz=0;
  cur=&top; //иниц. на тек.указател 
  find( nm);  //търсене на командата в списъка  -дали не записана преди
  if(*cur)  /* режим на включване */
  {
    if((*cur)->numb==nm)/* запис върху съществуващ запис */
    {  
       temp=(*cur)->next; /* запомняне на адреса на следващия елемент */
       nmz=temp->numbnz;
       *cur=new NodeT(nm,nmz,val,mn,mx,text,bcur);
            if(*cur)
       {
                  (*cur)->next=temp; /* инициализиране на указателя към следващия елемант */
                  return TRUE;
       }
       else
       {
            (*cur)->next=temp;
                  return FALSE;
            }
    }
    else
    {    
      /* добавяне на запис пред друг ,когато е с по-малък номер */
            (*cur)->back=new NodeT(nm,(*cur)->numbnz,val,mn,mx,text,bcur);
            if((*cur)->back)
            {
                  (*cur)->back->next=(*cur);/* инициализиране на указателя към предходния 
                                 (на следващия елемент ) с адреса на текущия запис  */
            bcur->next=(*cur)->back; /* инициализиране на указателя към следващия елемент */
                  nb++;   /* увеличаване на броя записи */
                  for(unsigned i=(*cur)->numbnz+1;i<=nb;i++,cur=&(*cur)->next)
                        (*cur)->next->numbnz=i;
               return TRUE;
       }
       else
           return FALSE;
    }
  }
  else   /* режим добавяне в края на списъка  */
  {     
      *cur=new  NodeT(nm,nb+1,val,mn,mx,text,bcur);            
      if(*cur)
      {
            nb++;
            return TRUE;
      }
      else
        return FALSE;
  }
}

/*********************************************************************/
/* ListNode::add :Добавяне на възел със зададен номер      */
/* Вход  : номер на полето,вид на записа - еднотекстов или многотекстов */
/*             име на файла ,брой текстове при многотекстовите        */
/* Изход :Няма                                                                 */
/************************************************************************/
flag ListNode::add(unsigned nm)
{
  NodeT*temp;
  unsigned nmz=0;
  cur=&top; //иниц. на тек.указател 
  find( nm);  //търсене на командата в списъка  -дали не записана преди
  if(*cur)  /* режим на включване */
  {
    if((*cur)->numb==nm)/* запис върху съществуващ запис */
    {  
       temp=(*cur)->next; /* запомняне на адреса на следващия елемент */
       nmz=(*cur)->numbnz;//номер на записа
       *cur=new NodeT(nm,nmz,bcur);
            if(*cur)
      {
                  (*cur)->next=temp; /* инициализиране на указателя към следващия елемант */
                  return TRUE;
      }
       else
       {
             (*cur)->next=temp;
                   return FALSE;
            }
    }
    else
    {    
      /* добавяне на запис пред друг ,когато е с по-малък номер */
      (*cur)->back=new NodeT(nm,(*cur)->numbnz,bcur);
      if((*cur)->back)
      {
            (*cur)->back->next=(*cur);/* инициализиране на указателя към предходния 
                                 (на следващия елемент ) с адреса на текущия запис  */
          bcur->next=(*cur)->back; /* инициализиране на указателя към следващия елемент */
            nb++;   /* увеличаване на броя записи */
            temp=*cur;
            cur=&(*cur)->next   ;
            while(*cur)
             {
               (*cur)->numbnz=(*cur)->back->numbnz+1;
                cur=&(*cur)->next   ;
              }
            cur=&temp;
            return TRUE;
       }
       else
      return FALSE;
    }
  }
  else   /* режим добавяне в края на списъка  */
  {     
      *cur=new  NodeT(nm,nb+1,bcur);            
      if(*cur)
      {
            nb++;
            return TRUE;
      }
      else
        return FALSE;
  }
}


/***************************************************************************************/
/* ListNode ::eraseNodeT : Изтриване на елемент с посочен ключ от списъка */
/* Вход  :Ключ на елемента                                                                    */
/* Изход:Няма                                                                                         */
/****************************************************************************************/
void   ListNode::eraseNodeT(unsigned  number)
{
   NodeT *p;   
   cur =&top; 
   find(number);/* търсене на запис с посочения номер */
   if(!*cur || (*cur)->numb!=number)  /* не съществува */
     return;
   else
   {
     p=*cur;
     if(!(*cur)->next) /* последен елемант */
     {   
      delete *cur;
      *cur=NULL;
      nb--;
     }
     else     /* не е последен */
     {      
      /* запомняне на указателите към предходния и следващия елемент */
      bcur=(*cur)->back;
      *cur=(*cur)->next;
      delete p;
      nb--; 
      (*cur)->back=bcur;
      p=*cur;
    while(*cur)
       {
               (*cur)->numbnz=(*cur)->back->numbnz+1;
                cur=&(*cur)->next   ;
    }
    cur=&p;
     }
     return;
   }
}

/**********************************************************************************************/
/* NodeT::NodeT :Конструктор на класс NodeT-абстрактен клас             */
/* Вход : Номер (ключ ) на елемента,указател към предходния */
/* Изход:Няма                                                                                                  */
/**************************************************************************************************/
NodeT::NodeT(unsigned nm,unsigned nmz,double val,double mn,double mx,char *text,NodeT *bc)
{
   numb=nm; /* номер на полето  -зададен от потребителя*/
   numbnz=nmz;
   min=mn;
   max=mx;
   value=val;
  name=new char [20 +1]; //заделяне на памет за име
   memset(name,' ',20);

   if(text!=NULL)
   {       
     unsigned len=strlen(text) ;
     strcpy(name,text);     //име
     *(name+len)=' ';      
    
   }     
   *(name+20)='\0';

   next=NULL; /* указател към следващото поле */
   back=bc;   /* указател към предходното */
}

NodeT::~NodeT(void)
{
   delete name;
}
/**********************************************************************************************/
/* NodeT::NodeT :Конструктор на класс NodeT-абстрактен клас             */
/* Вход : Номер (ключ ) на елемента,указател към предходния */
/* Изход:Няма                                                                                                  */
/**************************************************************************************************/
NodeT::NodeT(unsigned nm,unsigned nmz,NodeT *bc)
{
   numb=nm; /* номер на полето  -зададен от потребителя*/
   numbnz=nmz;
   value=0;       
   min=0;
   max=0;
   name=new char [20 +1]; //заделяне на памет за име
   memset(name,' ',20);
  *(name+20)='\0';
   next=NULL; /* указател към следващото поле */
   back=bc;   /* указател към предходното */
}

/**********************************************************************************************/
/* ListNode::ListNode :Конструктор на класс ListNode                                            */
/* Вход : Няма                                                                                                */
/* Изход:Няма                                                                                                  */
/**************************************************************************************************/
ListNode::ListNode()
{
  top=0;       /* указател към началото на списъка */
  cur=&top; /* указател към текущото поле */
  bcur=top; /* указател към последното поле */
  nb=0;  /* брой на полетата */
}

/*********************************************************************/
/* ListNode::removeall:Изтриване (унищожаване) на списъка */
/* Вход  : Начало на списъка                                            */
/* Изход : Няма                                                                 */
/**********************************************************************/
ListNode::~ListNode()
{
   removeall(&top);
}

/*********************************************************************/
/* ListNode::saveNodeT : Запис във файл на списъка с начало p */
/* Вход  :  Указател към файла , указател към възела  */
/* Изход     : Няма                                      */
/******************************************************/
void ListNode::saveNodeT(FILE *f,NodeT *p)
{
  if(p)
  {   
  /* запис на данните във файла по тип на полето */
    fprintf(f," %u %.3lf",p->numb,p->value);
    if(*p->name!=' ')
      fprintf(f," %s",p->name);
    else
      fprintf(f," %s","0");
     fprintf(f," %.3lf %.3lf",p->min,p->max); 
     saveNodeT(f,p->next); /* рекурсивно извикване */
   }
}     
 
/*********************************************************************/
/* ListNode::saveall : Запис на списък във файл                      */
/* Вход  : Име на  файла                                               */
/* Изход     : Резултат                                   */
/******************************************************/
void  ListNode::saveall( char *nf )
{    
   FILE *f;
   NodeT *p=top;  
   if(p)
   {
      f=fopen(nf,"w+t");  /* отваряне на файла */
      if(f==NULL)
      return ;
      else
      {
      fprintf(f,"%d",nb);  /*  брой полета */
      saveNodeT(f,top);    
      fclose (f);
       return ;
      }
   }
   else
    return ;
}
  

/*********************************************************************/
/* ListNode::load:Четене на списъка от файл                           */
/* Вход  : Име на  файла                                               */
/* Изход     : Резултат                                     */
/******************************************************/    
void ListNode::load(char *nf)
{
   FILE *f;  /* указател към файла */
   int numb=0; /* брой полета  */
   unsigned nm=0;/* номер на поле */                   
   double val=0.0;
   double mn=0.0;
   double mx=0.0;
   char buffer[20];
   
   f=fopen(nf,"r+t");  /*отваряне на файла */
   if(f==NULL)
    return ;
   else
   {
     fscanf(f,"%d",&numb);/* прочитане на броя записи(полета) */
     for(int i1=0;i1<numb;i1++)
     {        
      fscanf(f," %u %lf %s %lf %lf",&nm,&val,&buffer,&mn,&mx);
      if(buffer[0]!='0')
        add(nm,val,mn,mx,buffer);/* добавяне в списъка */
      else                                                                                        
        add(nm,val,mn,mx,NULL);/* добавяне в списъка */
     }
     fclose(f);   
   }
}

               
/*========================================================*/
/*  ReadParamMem: Чете посочения параметър от паметта                 */
/*  Входни данни: Номер на параметъра ,асрес на променливата за стойност на парам. */
/*  Изходни данни:Флаг за прочетен параметър                                                     */
/*                                   FALSE - няма параметър                                                           */
/*                                    TRUE - има параметър                                                              */
/*======================================================== */
flag ReadParamMem(unsigned nm , char type,void *aval)
{
    listnode.cur=&listnode.top;
    listnode.find(nm);
    if(!*listnode.cur || (*listnode.cur)->numb!=nm)  /* не съществува */
    {
       //error
       return FALSE;
    }
    else
    {
       switch (type)
       {
          case 'i':
            *(int *)aval=(int )(*listnode.cur)->value;
            break;
          case 'u':
            *(unsigned *)aval=(unsigned )(*listnode.cur)->value;
            break;
         case 'l':
            *(long *)aval=(long )(*listnode.cur)->value;
            break;
          case 'b':
            *(unsigned long *)aval=(unsigned long)(*listnode.cur)->value;
            break;
          case 'd':
            *(double *)aval=(*listnode.cur)->value;
            break;
        }
       return TRUE;
    }
}


