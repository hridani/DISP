/*****************************************************************************/
/*                           S T R U C T   F I L E                                   */
/*----------------------------------------------------------------------------------------------*/
/*     Описание на функциите от клас STUCT FILE                      */
/*****************************************************************************/
/*==========Заглавни файлове=======================*/
#include <conio.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <vmemory.h>
#include "..\include\stfile.h"
#include "..\include\memnew.h"
#include "..\include\svga.h"
extern flag permission;

/*********************************************************************/
/* ListFile::removeall:Изтриване (унищожаване) на списъка */
/* Вход  : Начало на списъка                                            */
/* Изход : Няма                                                                 */
/**********************************************************************/
void ListFile::removeall(BaseFile **p)
{
  if(*p==NULL)
    return;
  removeall(&((*p)->next)); // Изтриване на наследниците 
  delete *p;                           // Изтриване на началото
  nb--;
  *p=NULL;
}

/*********************************************************************/
/* ListFile::find:Търсене на елемент от списъка                  */
/* Вход  : Ключ за търсене                                               */
/* Изход : Няма                                                                 */
/**********************************************************************/
void ListFile::find(int number)
{ 
  if(*cur==NULL)    /* празен списък */
   return;
  if((*cur)->numb==number) /* проверка за номера */
    return;
  bcur=*cur;  /* указател към последния елемент */
  cur=&(*cur)->next; /* следващия */
  find(number);  /* рекурсивно извикване */
}

/*********************************************************************/
/* ListFile::find:Търсене на елемент от списъка - сортирано */
/*                     по възходящ ред на номера                  */
/* Вход  : Ключ за търсене                                               */
/* Изход : Няма                                                                 */
/**********************************************************************/
void ListFile::finds (int number)
{ 
  if(*cur==NULL)    /* празен списък */
   return;
  if((*cur)->numb>=number) /* проверка за номера */
    return;
  bcur=*cur;  /* указател към последния елемент */
  cur=&(*cur)->next; /* следващия */
  if(*cur)
  {
     if((*cur)->numb>number) /* проверка за номера на следващия */
       return;
  }
  finds(number);  /* рекурсивно извикване */
}


/*********************************************************************/
/* ListFile::findnz:Търсене на елемент от списъка                  */
/* Вход  : Ключ за търсене- номер на елемента   в списъка                */
/* Изход : Няма .Намереният елемент се предава чрез текущия */
/*             указател cur,ако няма елемент *cur=NULL               */
/**********************************************************************/
void ListFile::findnz (int number)
{ 
  if(*cur==NULL)    /* празен списък */
   return;
  if((*cur)->nmzapis==number) /* проверка за номера */
    return;
  bcur=*cur;  /* указател към последния елемент */
  cur=&(*cur)->next; /* следващия */
  findnz(number);  /* рекурсивно извикване */
}

 /***************************************************************************************/
/* ListFile ::L_get_last : Търсeнe на последния елемент в списъка        */
/* Вход  :Няма                                                                                       */
/* Изход:Няма                                                                                         */
/****************************************************************************************/
void ListFile::L_get_last()
 {
   if(*cur==NULL) /* ако няма елементи излиза */
    return ;
   if((*cur)->next==NULL) /* ако няма следващ излиза */
    return ;
   cur=&(*cur)->next; /* следващия */
   L_get_last();  /* рекурсивно извикване */
}

/*********************************************************************/
/* ListFile::add :Добавяне на възел със зададен номер      */
/* Вход  : номер на рада във файла,текст ,номер на реда от файла*/
/*             (след команда N)                                                           */
/* Изход : Флаг за успешно или не добавяне на реда(възел) в списъка*/
/************************************************************************/
flag ListFile::add(int nm,char *name,unsigned nmf)
{
  BaseFile*temp;
  int nmz=0;
  cur=&top; //иниц. на тек.указател 
  bcur=NULL;
  findnz( nm);  //търсене на командата в списъка  -дали не записана преди
  if(*cur)  /* режим на включване */
  {
    if((*cur)->nmzapis==nm)/* запис върху съществуващ запис */
    {  
       temp=*cur;//запомняне на текущия запис
        cur=&top; //иниц. на тек.указател 
       find( nmf);  //търсене на командата в списъка  -дали не записана преди със същия номер N
         if(!*cur || (*cur)->numb!=nmf)//няма друг запис със същия номер
         {       
          	cur=&temp;//*cur=temp;
            (*cur)->back=new BaseFile(nmf,bcur,name);
	         if((*cur)->back)
      		{
            	(*cur)->back->next=(*cur);/* инициализиране на указателя към предходния 
                                           (на следващия елемент ) с адреса на текущия запис  */
     			if(bcur)                                      
        			bcur->next=(*cur)->back; /* инициализиране на указателя към следващия елемент */
    			else
       				top=(*cur)->back;
            	nb++;   /* увеличаване на броя записи */
          		temp=*cur;
          		int i=1;
          		cur=&top;
          		while(*cur)
          		{
		                (*cur)->nmzapis=i++;   
        		        cur=&(*cur)->next;
         		}
          		cur=&temp;
         }
         return TRUE;
       }//няма друг запис с номер N  
       else
       {    
           	*cur=temp;
       		temp=(*cur)->next; /* запомняне на адреса на следващия елемент */
       		nmz=(*cur)->nmzapis;//номер на записа
         	*cur=new BaseFile(nmf,bcur,name) ;
       		if(*cur)
       		{
        		(*cur)->next=temp; /* инициализиране на указателя към следващия елемент */
        		(*cur)->nmzapis=nmz;
        		return TRUE;
       		}
       		else
       		{
         		(*cur)->next=temp;
         		return FALSE;
        	}
        }
    }
    else
    {    
      /* добавяне на запис пред друг ,когато е с по-малък номер */
        (*cur)->back=new BaseFile(nmf,bcur,name);
        
      if((*cur)->back)
      {
            (*cur)->back->next=(*cur);/* инициализиране на указателя към предходния 
                                           (на следващия елемент ) с адреса на текущия запис  */
     if(bcur)                                      
        bcur->next=(*cur)->back; /* инициализиране на указателя към следващия елемент */
    else
       top=(*cur)->back;
            nb++;   /* увеличаване на броя записи */
          temp=*cur;
          int i=1;
          cur=&top;
          while(*cur)
          {
                (*cur)->nmzapis=i++;   
                cur=&(*cur)->next;
         }
          cur=&temp;
            return TRUE;
      }
      else
        return FALSE;
    }
  }
  else   /* режим добавяне в края на списъка  */
  {     
        *cur=new BaseFile(nmf,bcur,name);            
        if(*cur)
        {
            nb++;
            (*cur)->nmzapis=nb;
            return TRUE;
        }
        else
          return FALSE;
  }
}

  flag ListFile::addn(int nm,char *name,unsigned nmf)
{
  BaseFile*temp;
  int nmz=0;
  cur=&top; //иниц. на тек.указател 
  bcur=NULL;
  findnz( nm);  //търсене на командата в списъка  -дали не записана преди
  if(*cur)  /* режим на включване */
  {
    if((*cur)->nmzapis==nm)/* запис върху съществуващ запис */
    {  
       temp=*cur;//запомняне на текущия запис
        cur=&top; //иниц. на тек.указател 
       find( nmf);  //търсене на командата в списъка  -дали не записана преди със същия номер N
         if(!*cur || (*cur)->numb!=nmf)//няма друг запис със същия номер
         {       
          	cur=&temp;//*cur=temp;
            (*cur)->back=new BaseFile(nmf,bcur,name);
	         if((*cur)->back)
      		{
            	(*cur)->back->next=(*cur);/* инициализиране на указателя към предходния 
                                           (на следващия елемент ) с адреса на текущия запис  */
     			if(bcur)                                      
        			bcur->next=(*cur)->back; /* инициализиране на указателя към следващия елемент */
    			else
       				top=(*cur)->back;
            	nb++;   /* увеличаване на броя записи */
          		temp=*cur;
          		int i=1;
          		cur=&top;
          		while(*cur)
          		{
		                (*cur)->nmzapis=i++;   
        		        cur=&(*cur)->next;
         		}
          		cur=&temp;
         }
         return TRUE;
       }//няма друг запис с номер N  
       else
       {    
           	*cur=temp;
       		temp=(*cur)->next; /* запомняне на адреса на следващия елемент */
       		nmz=(*cur)->nmzapis;//номер на записа
         	*cur=new BaseFile(nmf,bcur,name) ;
       		if(*cur)
       		{
        		(*cur)->next=temp; /* инициализиране на указателя към следващия елемент */
        		(*cur)->nmzapis=nmz;
        		return TRUE;
       		}
       		else
       		{
         		(*cur)->next=temp;
         		return FALSE;
        	}
        }
    }
    else
    {    
      /* добавяне на запис пред друг ,когато е с по-малък номер */
        (*cur)->back=new BaseFile(nmf,bcur,name);
        
      if((*cur)->back)
      {
            (*cur)->back->next=(*cur);/* инициализиране на указателя към предходния 
                                           (на следващия елемент ) с адреса на текущия запис  */
     if(bcur)                                      
        bcur->next=(*cur)->back; /* инициализиране на указателя към следващия елемент */
    else
       top=(*cur)->back;
            nb++;   /* увеличаване на броя записи */
          temp=*cur;
          int i=1;
          cur=&top;
          while(*cur)
          {
                (*cur)->nmzapis=i++;   
                cur=&(*cur)->next;
         }
          cur=&temp;
            return TRUE;
      }
      else
        return FALSE;
    }
  }
  else   /* режим добавяне в края на списъка  */
  {     
        *cur=new BaseFile(nmf,bcur,name);            
        if(*cur)
        {
            nb++;
//            (*cur)->nmzapis=nb;
            (*cur)->nmzapis=nm;
            return TRUE;
        }
        else
          return FALSE;
  }
}


ListFile ListFile::operator = (ListFile& lf)
{
   removeall(&top);
   lf.cur=&lf.top;
   while(*lf.cur)                                
   {
      addn((*lf.cur)->nmzapis,(*lf.cur)->ptext,(*lf.cur)->numb);//промяна на 24.04.2001 адд->аддн
      lf.cur=&(*lf.cur)->next;
    } 
    //numbrow=lf.numbrow;                                       
    return *this;
}
   
 
/***************************************************************************************/
/* ListFile ::eraseFilenz : Изтриване на елемент с посочен ключ от списъка- */
/*                                             пореден номер  на реда въд файла                                   */
/* Вход  :Ключ на елемента                                                                    */
/* Изход:Няма                                                                                         */
/****************************************************************************************/
void   ListFile::eraseFilenz(int  number)
{
   BaseFile *p;   
   cur =&top; 
   findnz(number);/* търсене на запис с посочения номер */
   if(!*cur)  /* не съществува */
     return;
   else
   {
     p=*cur;
     if(!(*cur)->next) /* последен елемант */
     {   
        delete *cur;
        *cur=NULL;
        nb--;
     }
     else     /* не е последен */
     {      
        /* запомняне на указателите към предходния и следващия елемент */
        bcur=(*cur)->back;
        *cur=(*cur)->next;
        delete p;
        nb--;                  
        (*cur)->back=bcur;
         p=*cur;
         while(p)
          {
             if(p->back!=NULL)
               p->nmzapis=p->back->nmzapis+1;
             else
               p->nmzapis=1;
             p=p->next   ;
         }
        //cur=&p;
     }
     return;
   }
}

/***************************************************************************************/
/* ListFile ::eraseFile: Изтриване на елемент с посочен ключ от списъка -*/
/*                                        номер на реда в CNC файла                                                  */
/* Вход  :Ключ на елемента                                                                    */
/** Изход:Няма                                                                                         */
/****************************************************************************************/
void   ListFile::eraseFile(int  number)
{
   BaseFile *p;   
   cur =&top; 
   find(number);/* търсене на запис с посочения номер */
   if(!*cur)  /* не съществува */
     return;
   else
   {
     p=*cur;
     if(!(*cur)->next) /* последен елемант */
     {   
        delete *cur;
        *cur=NULL;
        nb--;
     }
     else     /* не е последен */
     {      
        /* запомняне на указателите към предходния и следващия елемент */
        bcur=(*cur)->back;
        *cur=(*cur)->next;
        delete p;
        nb--;                  
        (*cur)->back=bcur;
         p=*cur;
         while(p)
          {   
            if(p->back!=NULL)
               p->nmzapis=p->back->nmzapis+1;
            else
              p->nmzapis=1;
           p=p->next   ;
         }
        //cur=&p;
     }
     return;
   }
}

/**********************************************************************************************/
/* BaseFile::BaseFile :Конструктор на класс BaseFile-абстрактен клас             */
/* Вход : Номер (ключ ) на елемента,указател към предходния */
/* Изход:Няма                                                                                                  */
/**************************************************************************************************/
BaseFile::BaseFile(int nm,BaseFile*bc,char *name)
{
   numb=nm; /* номер на полето  -зададен от потребителя*/
   nmzapis=0; // номер на записа в списъка -пореден номер
   ptext=new char [strlen(name) +1];//заделяне на памет за текст
//   NewMemoryUMB((void**)(&ptext),strlen(name)+1);
   if(ptext!=NULL)
     strcpy(ptext,name); //текст
   next=NULL; /* указател към следващото поле */
   back=bc;   /* указател към предходното */
   }
                                     
BaseFile::~BaseFile()
{
 delete ptext;   //освобождаване на паметта от текста        
  // FreeUMB(ptext);
}

void BaseFile::change(char *text)
{
   //FreeUMB(ptext);      
      delete(ptext);
   //NewMemoryUMB((void**)(&ptext),strlen(text)+1);               
   ptext=new char[strlen(text) +1];
   if(ptext!=NULL)
   {
     strcpy(ptext,text); //текст
    }
   else
       dprint(0,60,1,0x70,"NOMemoryC    ");    
}           

 
/**********************************************************************************************/
/* ListFile::ListFile :Конструктор на класс ListFILE                                            */
/* Вход : Няма                                                                                                */
/* Изход:Няма                                                                                                  */
/**************************************************************************************************/
ListFile::ListFile()
{
  top=0;       /* указател към началото на списъка */
  cur=&top; /* указател към текущото поле */
  bcur=top; /* указател към последното поле */
  nb=0;  /* брой на полетата */
}

/*********************************************************************/
/* ListFile::removeall:Изтриване (унищожаване) на списъка */
/* Вход  : Начало на списъка                                            */
/* Изход : Няма                                                                 */
/**********************************************************************/
ListFile::~ListFile()
{
   removeall(&top);
}

/**********************************************************************************************/
/* ListRecFile::ListFile :Конструктор на класс ListRecFILE                               */
/* Вход : Няма                                                                                                */
/* Изход:Няма                                                                                                  */
/**************************************************************************************************/
ListRecFile::ListRecFile()
{
  top=0;       /* указател към началото на списъка */
  cur=&top; /* указател към текущото поле */
  nm=0;  /* брой на полетата */
}

/**********************************************************************************************/
/* ListRecFile::ListFile : Деструктор на класс ListRecFILE                                 */
/* Вход : Няма                                                                                                */
/* Изход:Няма                                                                                                  */
/**************************************************************************************************/
ListRecFile::~ListRecFile()
{
   removeall(&top);
}

/**********************************************************************************************/
/* RecFile::RecFile :Конструктор на класс RecFILE                                            */
/* Вход : Име на файла ,флаг -кое име се задава- на диска или в паметта                                                                                  */
/* Изход:Няма                                                                                                  */
/**************************************************************************************************/
RecFile::RecFile(char *name,byte define)
{    
  if(define==1) //задаване на име на диска
  {
   nmfiledisk=new char [strlen(name) +1]; //заделяне на памет
   strcpy(nmfiledisk,name); //име на файла
   nmfilemem=NULL; //няма име в паметта
 }
 else  //задавне име в паметта
 {
    nmfilemem=new char [strlen(name) +1]; //заделяне на памет
   strcpy(nmfilemem,name); //име в паметта
   nmfiledisk=NULL; //няма име на диска
 }
   memfile=NULL; /* указател към записания файл в ОП */
   next=NULL; /* указател към следващото поле */
}

/***************************************************************************************/
/* RecFile: Деструктор на клас RecFile                                            */
/*  Входни данни :Няма                                                                       */
/*  Изходни данни:Няма                                                                       */
/***************************************************************************************/
  RecFile::~RecFile()
  { 
    if(nmfiledisk!=NULL)
    delete nmfiledisk;//освобождаване на паметта от името на файла на диска
    if(nmfilemem!=NULL)
    delete nmfilemem;//освобождаване на паметта от името на файла в паметта
    if(memfile!=NULL)       
    FreeMemory(memfile);
   //FreeUMB(memfile);
  }

/*********************************************************************/
/* ListRecFile::add :Добавяне на възел със зададено име      */
/* Вход  : име на файла                         */
/* Изход :Няма                                                                 */
/************************************************************************/
flag ListRecFile::adddisk(char *name)
{
  cur=&top; 
  finddisk( name);
  if(*cur)  /* режим на включване */
    return FALSE;
  else   /* режим добавяне в края на списъка  */
  {                                                  
        *cur=new RecFile(name,1);
        if(*cur)
        {
            nm++;
            return TRUE;
        }
        else
         return FALSE;
  }
}

/*********************************************************************/
/* ListRecFile::add :Добавяне на възел със зададено име      */
/* Вход  : име на файла                         */
/* Изход :Няма                                                                 */
/************************************************************************/
flag ListRecFile::addmem(char *name)
{
  cur=&top; 
  findmem( name);
  if(*cur)  /* режим на включване */
    return FALSE;
  else   /* режим добавяне в края на списъка  */
  {                                                  
        *cur=new RecFile(name,2);
        if(*cur)
        {
            nm++;
            return TRUE;
        }
        else
         return FALSE;
  }
}


/*********************************************************************/
/* ListRecFile::find:Търсене на елемент от списъка                  */
/* Вход  : Ключ за търсене                                               */
/* Изход : Няма                                                                 */
/**********************************************************************/
void ListRecFile::finddisk (char *name)
{     
  int cond;
  if(*cur==NULL)    /* празен списък */
   return;
  if((cond=_stricmp((*cur)->nmfiledisk,name))==0) /* проверка за номера */
    return;
  cur=&(*cur)->next; /* следващия */
  finddisk(name);  /* рекурсивно извикване */
}

/*********************************************************************/
/* ListRecFile::find:Търсене на елемент от списъка                  */
/* Вход  : Ключ за търсене                                               */
/* Изход : Няма                                                                 */
/**********************************************************************/
void ListRecFile::findmem (char *name)
{     
  int cond;
  if(*cur==NULL)    /* празен списък */
   return;
  if((cond=strcmp((*cur)->nmfilemem,name))==0) /* проверка за номера */
    return;
  cur=&(*cur)->next; /* следващия */
  findmem(name);  /* рекурсивно извикване */
}


/***************************************************************************************/
/* ListRecFile ::eraseRecFile : Изтриване на елемент с посочен ключ от списъка */
/* Вход  :Ключ на елемента                                                                    */
/* Изход:Няма                                                                                         */
/****************************************************************************************/
void   ListRecFile::eraseRecFile(char *name)
{
   RecFile *p;   
   cur =&top; 
   finddisk(name);/* търсене на запис с посочения номер */
   if(!*cur)  /* не съществува */
   {
     cur =&top; 
     findmem(name);
     if(!*cur)
      return;
    }
     p=*cur;
     if(!(*cur)->next) /* последен елемент */
     {   
        delete *cur;
        *cur=NULL;
        nm--;
     }
     else     /* не е последен */
     {      
        /* запомняне на указателите към предходния и следващия елемент */
        *cur=(*cur)->next;
        delete p;
        nm--;
     }
     return;
}

/*********************************************************************/
/* ListRecFile::removeall:Изтриване (унищожаване) на списъка */
/* Вход  : Начало на списъка                                            */
/* Изход : Няма                                                                 */
/**********************************************************************/
void ListRecFile::removeall(RecFile **p)
{
  if(*p==NULL)
    return;
  removeall(&((*p)->next)); // Изтриване на наследниците 
  delete *p;                           // Изтриване на началото
  nm--;
  *p=NULL;
 }


/*********************************************************************/
/* ListFile::saveList: Запис във файл на списъка с начало p */
/* Вход  :  Указател към файла , указател към възела  */
/* Изход     : Няма                                      */
/******************************************************/
void ListFile::saveList(FILE *f,BaseFile *p)
{
  if(p)
  {   
  /* запис на данните във файла по тип на полето */
    fprintf(f," %d %d %s",((BaseFile *)p)->numb,
                    ((BaseFile *)p)->nmzapis,((BaseFile *)p)->ptext);
      saveList(f,p->next); /* рекурсивно извикване */
   }
}     
 
/*********************************************************************/
/* ListFile::saveall : Запис на списък във файл                      */
/* Вход  : Име на  файла                                               */
/* Изход     : Резултат                                   */
/******************************************************/
void  ListFile::saveall( char *nf )
{    
   FILE *f;
   BaseFile *p=top;  
   if(p)
   {
      f=fopen(nf,"w");  /* отваряне на файла */
      if(f==NULL)
        return ;
      else
      {
        fprintf(f,"%d",nb);  /*  брой полета */
        saveList(f,top);    
        fclose (f);
         return ;
      }
   }
   else
    return ;
}
  

/*********************************************************************/
/* ListFile::load:Четене на списъка от файл                           */
/* Вход  : Име на  файла                                               */
/* Изход     : Резултат                                     */
/******************************************************/    
unsigned char ListFile::load(char *nf)
{
   FILE *f;  /* указател към файла */
   int numb=0; /* брой полета  */
   int nm=0;/* номер на поле */
   int nmN=0;/*номер N */
   char istr[80];/* указател към текстовия низ */
   
   f=fopen(nf,"r");  /*отваряне на файла */
   if(f==NULL)
    return 0;
   else
   {
     fscanf(f,"%d ",&numb);/* прочитане на броя записи(полета) */
     for(int i1=0;i1<numb;i1++)
     {        
        fscanf(f,"%d %d %s ",&nm,&nmN,istr);
        add(nm,istr,nmN);/* добавяне в списъка */
     }
     fclose(f);   
     return 1;
   }
}

