/*****************************************************************************/
/*                               V I D E I O   F I E L D                               */
/*----------------------------------------------------------------------------------------------*/
/*     Описание на функциите от клас Offset                            */
/*****************************************************************************/
/*==========Заглавни файлове=======================*/
#include <conio.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "..\include\offset.h"



/*********************************************************************/
/* Offset::Offset:Конструктор на клас "Offset"                   */
/* Вход  : номер на полето,номер на ножа,брой действителни параметри*/
/*              указател към предходното поле*/
/* Изход     : Няма                                                          */
/*********************************************************************/
Offset::Offset(int nm,int nt,int npr,Offset *bc)
{
   numb=nm; /* номер на полето */
   numbtool=nt;
   npar=npr;
   kdw=0;
   for(int i=0;i<npar;i++)
        par[i]=0;
   next=NULL; /* указател към следващото поле */
   back=bc;   /* указател към предходното */
}

/*********************************************************************/
/* Offset::Offset:Конструктор на клас "Offset"                   */
/* Вход  : номер на полето,номер на ножа,брой действителни параметри*/
/*              указател към предходното поле*/
/* Изход     : Няма                                                          */
/*********************************************************************/
Offset::Offset(int nm,int nt,int kd_dw,Offset *bc,double par1,double par2)
{
   numb=nm; /* номер на полето */
   numbtool=nt;
   npar=0;
   kdw=kd_dw;
     par[0]=par1;
     npar++;
     par[1]=par2;
     npar++;
   next=NULL; /* указател към следващото поле */
   back=bc;   /* указател към предходното */
}
    
/*********************************************************************/
/* ListOF::ListOF :Конструктор на клас "ListOF"                   */
/* Вход  : Няма                                                                  */
/* Изход     : Няма                                                          */
/*********************************************************************/
ListOF::ListOF()
{
  top=0;       /* указател към началото на списъка */
  cur=&top; /* указател към текущото поле */
  bcur=top; /* указател към последното поле */
  nb=0;  /* брой на полетата */
}
 
/*********************************************************************/
/* ListOF::removeall:Изтриване (унищожаване) на списъка */
/* Вход  : Начало на списъка                                            */
/* Изход : Няма                                                                 */
/**********************************************************************/
ListOF::~ListOF()
{
   removeall(&top);
}

/*********************************************************************/
/* ListOF::L_det_last : Връща указател към последния елемент в списъка,чрез cur */
/* Вход  : Няма                                           */
/* Изход     : Няма                                        */
/******************************************************/
void ListOF::L_get_last()
{
   if((*cur)->next==NULL) /* последен възел */
    return ;
   if(*cur==NULL) /* няма елементи */
    return ;
   cur=&(*cur)->next; /* следващ елемент */
   L_get_last();  /* рекурсивно извикване */
}
             
  
/*********************************************************************/
/* ListOF::find : Търсене на възел с указан номер   */
/* Вход  :Номер на възeла ( поле )                        */
/* Изход     : Няма                                        */
/******************************************************/
void ListOF::find (int number)
{ 
  if(*cur==NULL)    /* празен списък */
   return;
  if((*cur)->numb==number) /* проверка за номера */
    return;
  bcur=*cur;  /* указател към последния елемент */
  cur=&(*cur)->next; /* следващия */
  if(*cur)
  {
     if((*cur)->numb>number) /* проверка за номера на следващия */
       return;
  }
  find(number);  /* рекурсивно извикване */
}
/*********************************************************************/
/* ListOF::findnt : Търсене на възел с указан номер на инструмент  */
/* Вход  :Номер на инструмента                                                    */
/* Изход     : Няма                                        */
/******************************************************/
void ListOF::findnt (int nmtl)
{ 
  if(*cur==NULL)    /* празен списък */
   return;
  if((*cur)->numbtool==nmtl) /* проверка за номера */
    return;
  cur=&(*cur)->next; /* следващия */
  findnt(nmtl);  /* рекурсивно извикване */
}

/*********************************************************************/
/* ListOF::findnt : Търсене на възел с указан номер на корекщионна двойка  */
/*                                 и номер на нож */
/* Вход  :Номер на инструмента                                                    */
/* Изход     : Няма                                        */
/******************************************************/
void ListOF::findtkw (int nmtl ,int k_dw)
{ 
  if(*cur==NULL)    /* празен списък */
   return;
  if((*cur)->numbtool ==nmtl && (*cur)->kdw==k_dw) /* проверка за номера */
    return;
  cur=&(*cur)->next; /* следващия */
  findtkw(nmtl,k_dw);  /* рекурсивно извикване */
}

/*********************************************************************/
/* ListOF::add :Добавяне на възел със зададен номер      */
/* Вход  : номер на полето,тип на полето,ред и колона,дължина, */
/*             цвят и фон на символите,указател към текст,            */
/* Изход :`Няма                                                                       */
/******************************************************/
void ListOF::add(int nm,int nmtl,int pr)
{
  Offset *temp;
  cur=&top; 
  find( nm);
  if(*cur)  /* режим на включване */
  {
    if((*cur)->numb==nm)/* запис върху съществуващ запис */
    {  
       temp=(*cur)->next; /* запомняне на адреса на следващия елемент */
       *cur=new Offset(nm,nmtl,pr,bcur);
        (*cur)->next=temp; /* инициализиране на указателя към следващия елемант */
    }
    else
    {    
      /* добавяне на запис пред друг ,когато е с по-малък номер */
      (*cur)->back=new Offset(nm,nmtl,pr,bcur);
      (*cur)->back->next=(*cur);/* инициализиране на указателя към предходния 
                                           (на следващия елемент ) с адреса на текущия запис  */
      bcur->next=(*cur)->back; /* инициализиране на указателя към следващия елемент */
      nb++;   /* увеличаване на броя записи */
    }
  }
  else   /* режим добавяне в края на списъка  */
  {                                                  
        *cur=new Offset(nm,nmtl,pr,bcur);
        nb++;
  }
}

/*********************************************************************/
/* ListOF::add :Добавяне на възел със зададен номер      */
/* Вход  : номер на полето,тип на полето,ред и колона,дължина, */
/*             цвят и фон на символите,указател към текст,            */
/* Изход :`Няма                                                                       */
/******************************************************/
void ListOF::add(int nm,int nmtl,int k_dw,double par1,double par2)
{
  Offset *temp;
  cur=&top; 
  find( nm);
  if(*cur)  /* режим на включване */
  {
    if((*cur)->numb==nm)/* запис върху съществуващ запис */
    {  
       temp=(*cur)->next; /* запомняне на адреса на следващия елемент */
       *cur=new Offset(nm,nmtl,k_dw,bcur,par1,par2);
        (*cur)->next=temp; /* инициализиране на указателя към следващия елемант */
    }
    else
    {    
      /* добавяне на запис пред друг ,когато е с по-малък номер */
      (*cur)->back=new Offset(nm,nmtl,k_dw,bcur,par1,par2);
      (*cur)->back->next=(*cur);/* инициализиране на указателя към предходния 
                                           (на следващия елемент ) с адреса на текущия запис  */
      bcur->next=(*cur)->back; /* инициализиране на указателя към следващия елемент */
      nb++;   /* увеличаване на броя записи */
    }
  }
  else   /* режим добавяне в края на списъка  */
  {                                                  
       //temp=*cur;
       cur=&top; 
       findtkw(nmtl,k_dw);//търсене на нож със същия номер и корекц .дв
       if( !*cur)//няма такъв
       {
        *cur=new Offset(nm,nmtl,k_dw,bcur,par1,par2);
        nb++;
       }
  }
}
  
/*********************************************************************/
/* ListOF::eraseOffset:Изтриване на възел със зададено име */
/* Вход  : Номер на възела (поле)  */
/* Изход     : Резултат                                       */
/******************************************************/
void   ListOF::eraseOffset(int  number)
{
   Offset *p;   
   cur =&top; 
   find(number);/* търсене на запис с посочения номер */
   if(!*cur)  /* не съществува */
     return;
   else
   {
     p=*cur;
     if(!(*cur)->next) /* последен елемант */
     {   
        delete *cur;
        *cur=NULL;
        nb--;
     }
     else     /* не е последен */
     {      
        /* запомняне на указателите към предходния и следващия елемент */
        *cur=(*cur)->next;
        (*cur)->back=(*cur)->back->back;
        delete p;
        nb--;
     }
     return;
   }
}

/*********************************************************************/
/* ListOF::saveListOF : Запис във файл на списъка с начало p */
/* Вход  :  Указател към файла , указател към възела  */
/* Изход     : Няма                                      */
/******************************************************/
void ListOF::saveListOF(FILE *f,Offset *p)
{
  if(p)
  {   
  /* запис на данните във файла по тип на полето */
    fprintf(f," %d ",((Offset *)p)->numb);
      saveListOF(f,p->next); /* рекурсивно извикване */
   }
}     
 
/*********************************************************************/
/* ListOF::saveall : Запис на списък във файл                      */
/* Вход  : Име на  файла                                               */
/* Изход     : Резултат                                   */
/******************************************************/
void  ListOF::saveall( char *nf )
{    
   FILE *f;
   Offset *p=top;  
   if(p)
   {
      f=fopen(nf,"w+t");  /* отваряне на файла */
      if(f==NULL)
        return ;
      else
      {
        fprintf(f,"%d",nb);  /*  брой полета */
        saveListOF(f,top);    
        fclose (f);
         return ;
      }
   }
   else
    return ;
}
  

/*********************************************************************/
/* ListOF::load:Четене на списъка от файл                           */
/* Вход  : Име на  файла                                               */
/* Изход     : Резултат                                     */
/******************************************************/    
void ListOF::load(char *nf)
{
   FILE *f;  /* указател към файла */
   int numb=0; /* брой полета  */
   int nm=0;/* номер на поле */
   f=fopen(nf,"r+t");  /*отваряне на файла */
   if(f==NULL)
    return ;
   else
   {
     fscanf(f,"%d ",&numb);/* прочитане на броя записи(полета) */
     for(int i1=0;i1<numb;i1++)
     {        
        fscanf(f,"%d",&nm);
//        add(nm,rw,cl,ln,atr,istr);/* добавяне в списъка */
     }
     fclose(f);   
   }
}

                   
/*********************************************************************/
/* ListOF::removeall:Изтриване (унищожаване) на списъка   */
/* Вход  : Начало на списъка                                            */
/* Изход     : Няма                                      */
/******************************************************/
void ListOF::removeall(Offset **p)
{
  if(*p==NULL)
    return;
  removeall(&((*p)->next)); // Изтриване на наследниците 
  delete *p;                           // Изтриване на началото
  nb--;
  *p=NULL;
 }

