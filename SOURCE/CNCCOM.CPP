/****************************************************************************************/
/*                                 C N C C O M . C P P                                          */
/*   Описание на CNC команди ,буфери с CNC команди и списъци от буфери*/
/****************************************************************************************/
#include <string.h>
#include <stdlib.h>
#include <dos.h>       
#include <stdio.h>
#include <new.h>
#include "..\include\cnccom.h"
#include "..\include\svga.h"
#include "string.h"
extern flag permission;//флаг за работа с паметта

/***************************************************************************************/
/* CNCcom : Конструктор на клас CNCcom.Описание на CNC команда, */
/*  Входни данни :Име на  командата,приоритет,група,паралелност, */
/*                          флаг за декодиране на следващ ред,указател към функция */
/*  Изходни данни:Няма                                                                       */
/***************************************************************************************/
 CNCcom::CNCcom( char *nam,byte pr,byte gr ,flag par,flag nl ,TCNC cf) 
 {
    name=new char [strlen(nam) +1];   //заделяне на памет за името
    strcpy(name,nam);  //име на командата
    priority=pr;//приоритет
    group=gr;//група
    parallel=par;//парелелност
    nextline=nl;//следващ ред
    CNCfunc=cf;//функция
    next=NULL; //следваща команда
 }
 
/***************************************************************************************/
/* CNCcom : Деструктор на клас CNCcom.                                            */
/*  Входни данни :Няма                                                                       */
/*  Изходни данни:Няма                                                                       */
/***************************************************************************************/
CNCcom::~CNCcom()
 {
   delete name;//освобождаване на паметта за име на командата
 } 

/***************************************************************************************/
/* CNCcom ::operator new :Заделяне на памет за  данните на обект от този клас    */
/* Вход  :Размер на класа                                                                   */
/* Изход:Указател към заделената памет или NULL                                                */
/****************************************************************************************/
 void *CNCcom::operator new (size_t size)
 { 
    void  *pr;   //указател към заделената памет или NULL                         
    if(fNewMemory(&pr,size,&"CNCcom") ) //заделяне на памет -"MEMNEW.CPP"
     return pr;//има памет -указателя сочи заделената памет
    else
      return pr=NULL;//няма памет -NULL
 } 
     
  
/***************************************************************************************/
/* CNCcom ::operator delete:Освобождаване на паметта ,заделена за обект от   */
/*                                        този клас                                                               */
/* Вход  :Указател към заделената памет                                                           */
/* Изход:Няма                                               */
/****************************************************************************************/
  void CNCcom::operator delete(void *ptr)
  { 
    FreeMemory(ptr);//освобождаване на паметта -"MEMNEW.CPP"
  } 
  
  
/***************************************************************************************/
/* CNCList : Конструктор на клас CNCList.Създаване на списък от CNC команди  */
/*                 или обекти от клас CNCcom                                                       */
/*  Входни данни : Няма                                                                             */
/*  Изходни данни:Няма                                                                       */
/***************************************************************************************/
 CNCList::CNCList()   
  {
     top=NULL;//указател към първи елемент в списъка
     cur=&top;  //указател към текущ елемент                              
     nm=0;//брой елементи
   }   
           
/*********************************************************************/
/* CNCList::find:Търсене на елемент от списъка                  */
/* Вход  : Ключ за търсене-име на командата                  */
/* Изход : Няма .Намереният елемент се предава чрез текущия */
/*             указател cur,ако няма елемент *cur=NULL               */
/**********************************************************************/
  void CNCList::find(char *nam)
   {                       
      int cond; //резултат от сравнението
      if(*cur==NULL) //край на списъка
         return;
      if((cond=strcmp((*cur)->name,nam))==0) //намерен е елемента
         return;
      cur=&(*cur)->next; //следващ елемент
      find(nam);   //рекурсивно извикване
   } 

/*********************************************************************/
/* CNCList::add :Добавяне на възел със зададен указател към задача */
/*  Входни данни :Име на  командата,приоритет,група,паралелност, */
/*                          флаг за декодиране на следващ ред,указател към функция */
/* Изход :Флаг                                                                 */
/*             FALSE -неуспешно добавяне                             */
/*             TRUE   -успешно                                                 */
/************************************************************************/
flag CNCList::add( char *name,byte pr,byte gr ,flag par,flag nl ,TCNC cf) 
{
      cur=&top; //иниц. на тек.указател
      find(name);  //търсене на командата в списъка  -дали не записана преди
      if(*cur)   //има -изход
        return FALSE;
      else   //няма
      {
        *cur=new CNCcom(name,pr,gr,par,nl,cf);//добавяне                  
        if(*cur)// създаден е възела     
        {
           nm++;//увеличаване на брояча -елементи в списъка
          return TRUE;
        }
        else
          return FALSE;
      }
   }

/*********************************************************************/
/* CNCList::removeall:Изтриване (унищожаване) на списъка */
/* Вход  : Начало на списъка                                            */
/* Изход : Няма                                                                 */
/**********************************************************************/
   void CNCList::removeall(CNCcom **pcnc)
   {
     if(*pcnc==NULL)   //няма елементи
       return;
     removeall(&((*pcnc)->next)); //рекурсивно  извикване
     delete *pcnc; //изтриване на елемента 
     nm--;   //намаляване на брояча
     *pcnc=NULL; //указателя е NULL -не сочи елемент
   }

/***************************************************************************************/
/* CNCList ::eraseCNC : Изтриване на елемент с посочен ключ от списъка */
/* Вход  :Ключ на елемента - име на командата                                       */
/* Изход:Няма                                                                                         */
/****************************************************************************************/
void  CNCList::eraseCNC(char *nam)
{                
   CNCcom *pcnc=NULL;
   cur =&top; 
   find(nam);
   if(!*cur)  /* не съществува */
     return ;
   else
   {        
     pcnc=*cur;
     if(!(*cur)->next) /* последен елемант */
     {   
        delete *cur;
        *cur=NULL;
        nm--;
     }
     else     /* не е последен */
     {      
        /* запомняне на указателите към предходния и следващия елемент */
        *cur=(*cur)->next;
         delete pcnc;
        nm--;
     }
   }
}

  
/***************************************************************************************/
/* CNCList ::L_get_last : Търсeнe на последния елемент в списъка        */
/* Вход  :Няма                                                                                       */
/* Изход:Няма                                                                                         */
/****************************************************************************************/
 void CNCList::L_get_last()
{
   if(*cur==NULL) /* ако няма елементи излиза */
    return ;
   if((*cur)->next==NULL) /* ако няма следващ излиза */
    return ;
   cur=&(*cur)->next; /* следващия */
   L_get_last();  /* рекурсивно извикване */
}



/***************************************************************************************/
/* BUFcnc : Конструктор на клас BUFcnc.Създаване на буфер с команди  */
/*  Входни данни :Име на командата,параметър,приоритет,група,команда/данна,функция */
/*  Изходни данни:Няма                                                                       */
/***************************************************************************************/
BUFcnc::BUFcnc(char *nam,char *prm,byte pr,byte gr,byte k,TCNC func)
 {     
   permission=FALSE; //работа с паметта      
    name=new char [strlen(nam) +1]; //заделяне на памет за име
    strcpy(name,nam);   //име 
    param=new char [strlen(prm) +1];//заделяне на памет за параметър
    strcpy(param,prm);                      //параметър на командата
    permission=TRUE; //не се работи с паметта
    priority=pr;//приоритет
    group=gr;//група
    k_p=k;//команда или данна
    CNCfunc=func;//функция
    next=NULL;            //следващ елемент
}

/***************************************************************************************/
/* BUFcnc: Деструктор на клас BUFcnc                                            */
/*  Входни данни :Няма                                                                       */
/*  Изходни данни:Няма                                                                       */
/***************************************************************************************/
BUFcnc::~BUFcnc()
 { 
  permission=FALSE;//работа с паметта
     delete name; //освобождаване на паметта за име
     delete param;     //освобождаване на паметта за параметър
     permission=TRUE;//не се работи с паметта
 }                          
 
/***************************************************************************************/
/* BUFcnc::operator new :Заделяне на памет за  данните на обект от този клас    */
/* Вход  :Размер на класа                                                                   */
/* Изход:Указател към заделената памет или NULL                                                */
/****************************************************************************************/
void *BUFcnc::operator new (size_t size)
 { 
    void  *pr;              
    if(fNewMemory(&pr,size,&"BUFcnc") )
     return pr;
    else
      return pr=NULL;
 } 
     
  
/***************************************************************************************/
/* BUFcnc ::operator delete:Освобождаване на паметта ,заделена за обект от   */
/*                                        този клас                                                               */
/* Вход  :Указател към заделената памет                                                           */
/* Изход:Няма                                               */
/****************************************************************************************/
  void BUFcnc::operator delete(void *ptr)
  {   
    FreeMemory(ptr);
  } 
  
/***************************************************************************************/
/* BUFList : Конструктор на клас BUFList.Създаване на списък              */
/*  Входни данни : Няма                                                                             */
/*  Изходни данни:Няма                                                                       */
/***************************************************************************************/
  BUFList::BUFList()   
  {
     top=NULL; //указател към първи елемент в списъка
     cur=&top;   //указател към текущ елемент                                            
     nm=0;//брой елементи
   }   
           
/*********************************************************************/
/* BUFList::find:Търсене на елемент от списъка                  */
/* Вход  : Ключ за търсене-име на командата                  */
/* Изход : Няма .Намереният елемент се предава чрез текущия */
/*             указател cur,ако няма елемент *cur=NULL               */
/**********************************************************************/
  void BUFList::find(char *nam)
   {                                        
      int cond;     //резултат от сравнението
      if(*cur==NULL) //край на списъка
         return;
      if((cond=strcmp((*cur)->name,nam))==0) //намерен е елемента
         return;
      cur=&(*cur)->next;//следващ елемент
      find(nam);   //рекурсивно извикване
   } 

/*********************************************************************/
/* BUFList::find:Търсене на елемент от списъка                  */
/* Вход  : Ключ за търсене-приоритет на командата                  */
/* Изход : Няма .Намереният елемент се предава чрез текущия */
/*             указател cur,ако няма елемент *cur=NULL               */
/**********************************************************************/
   void BUFList::find(byte pr)
   {
      if(*cur==NULL)
         return;
      if((*cur)->priority==pr) /* проверка за приоритета */
          return;
      if((*cur)->next)// има ли следващ ?
      {
         if((*cur)->next->priority >pr) /* проверка за пиоритета на следващия ,дали е по-висок*/
          return;//да изход
      }
      cur=&(*cur)->next;//следващ елемент
      find(pr);   //рекурсивно извикване
} 

/*********************************************************************/
/* BUFList::addpr :Добавяне на възел с подредба по приоритет */
/* Входни данни :Име на командата,параметър,приоритет,група,команда/данна,функция */
/* Изход :Флаг                                                                 */
/*             FALSE -неуспешно добавяне                             */
/*             TRUE   -успешно                                                 */
/************************************************************************/
  flag BUFList::addpr( char *name,char *prm,byte pr,byte gr,byte k,TCNC  func) 
   {  
      BUFcnc *work;  //помощна променлива
      cur=&top;//иниц. на тек.указател
      find(name); //търсене на командата в списъка  -дали не записана преди
      if(*cur)     //има -изход
        return FALSE;
      else
      {
         cur=&top;
         if(top->priority > pr)//приоритета на началото > от тази на задачата за добавяне
         {       //добавяне преди началото
            work=(*cur);//запомняне на адреса на началото
            (*cur)=new BUFcnc(name,prm,pr,gr,k,func);//добавяне
            if(*cur!=NULL) //има запис в паметта
            {
               (*cur)->next=work;//свързване с началото
               nm++; //увеличаване на брояча -елементи в списъка
               return TRUE;
             }
            else
            {
               (*cur)=work;
               return FALSE;
            }
         }
         else
         {
            find(pr); //търсене на задачата с приоритет < от този на задачата за добавяне    
            if(!*cur) //няма задачи с по-нисък приоритет
            {
               *cur=new BUFcnc(name,prm,pr,gr,k,func);   //добавяне      
               if(*cur!=NULL)
               {
                  nm++;  //увеличаване на брояча -елементи в списъка
                  return TRUE;
               }
               else
                return FALSE;
             }
            else //има задачи с по-нисък приоритет                                    
            {
               work=(*cur)->next;//адрес на следващата команда
               (*cur)->next=new BUFcnc(name,prm,pr,gr,k,func);   //добавяне като следваща команда      
               if((*cur)->next!=NULL) // има заделена памет
               {
                 (*cur)->next->next=work; //иниц. на указателя за следваща команда
                 nm++;   //увеличаване на брояча -елементи в списъка
                 return TRUE;
                }
               else //няма заделена памет
               {
                 (*cur)->next=work;
                 return FALSE;
               }
             }
          }
      }
   }

/*********************************************************************/
/* BUFList::add :Добавяне на възел                                  */
/* Входни данни :Име на командата,параметър,приоритет,група,команда/данна,функция */
/* Изход :Флаг                                                                 */
/*             FALSE -неуспешно добавяне                             */
/*             TRUE   -успешно                                                 */
/************************************************************************/
   flag BUFList::add( char *name,char *prm,byte pr,byte gr,byte k,TCNC func) 
   {  
      cur=&top;  //иниц. на тек.указател
      find(name);  //търсене на командата в списъка  -дали не записана преди
      if(*cur)
        return FALSE;
      else
      {
            (*cur)=new BUFcnc(name,prm,pr,gr,k,func);//добавяне         
            if(*cur!=NULL)
            { 
               nm++;  //увеличаване на брояча -елементи в списъка
                   return TRUE;
                 }
                 else
                  return FALSE;
      }
   }

 /*********************************************************************/
/* BUFList::removeall:Изтриване (унищожаване) на списъка */
/* Вход  : Начало на списъка                                            */
/* Изход : Няма                                                                 */
/**********************************************************************/
   void BUFList::removeall(BUFcnc **pcnc)
   {
     if(*pcnc==NULL)     //няма елементи
       return;
     removeall(&((*pcnc)->next)); //рекурсивно  извикване
     delete *pcnc;//изтриване на елемента 
     nm--;   //намаляване на брояча
     *pcnc=NULL; //указателя е NULL -не сочи елемент
   }

/***************************************************************************************/
/* BUFList ::eraseBUF : Изтриване на елемент с посочен ключ от списъка */
/* Вход  :Ключ на елемента - име на командата                                       */
/* Изход:Няма                                                                                         */
/****************************************************************************************/
void  BUFList::eraseBUF(char *nam)
{                
   BUFcnc *pcnc=NULL;
   cur =&top; 
   find(nam);
   if(!*cur)  /* не съществува */
     return ;
   else
   {        
     pcnc=*cur;
     if(!(*cur)->next) /* последен елемант */
     {   
        delete *cur;
        *cur=NULL;
        nm--;
     }
     else     /* не е последен */
     {      
        /* запомняне на указателите към предходния и следващия елемент */
        *cur=(*cur)->next;
        delete pcnc;
        nm--;
     }       
   }
}

  
/***************************************************************************************/
/* BUFList ::L_get_last : Търсенe на последния елемент в списъка        */
/* Вход  :Няма                                                                                       */
/* Изход:Няма                                                                                         */
/****************************************************************************************/
 void BUFList::L_get_last()
{
   if(*cur==NULL) /* ако няма елементи излиза */
    return ;
   if((*cur)->next==NULL) /* ако няма следващ излиза */
    return ;
   cur=&(*cur)->next; /* следващия */
   L_get_last();  /* рекурсивно извикване */
}

/***************************************************************************************/
/* BUFList::operator new :Заделяне на памет за  данните на обект от този клас    */
/* Вход  :Размер на класа                                                                   */
/* Изход:Указател към заделената памет или NULL                                                */
/****************************************************************************************/
 void *BUFList::operator new (size_t size)
 { 
    void  *pr;              
    if(fNewMemory(&pr,size,&"BUFList") )
     return pr;
    else
      return pr=NULL;
 } 
     
  
/***************************************************************************************/
/* BUFList::operator delete:Освобождаване на паметта ,заделена за обект от   */
/*                                        този клас                                                               */
/* Вход  :Указател към заделената памет                                                           */
/* Изход:Няма                                               */
/****************************************************************************************/
  void BUFList::operator delete(void *ptr)
  {   
    FreeMemory(ptr);
  } 
 
/***************************************************************************************/
/* EIBUFList : Конструктор на клас EIBUFList.Описва буфера като елемент на списък*/
/*  Входни данни : Номер на буфера                                                                             */
/*  Изходни данни:Няма                                                                       */
/***************************************************************************************/
ElBUFList::ElBUFList(int num,int nm) 
 {
    numb=num; //номер на буфера
    numbz=nm;
    bl=new BUFList(); //създаване на буфер с указател към него 
    signal=0; //сигнал ,че командите  от буфера са декодирани
    next=NULL;//указател към следващия елемент
 }
                           
/***************************************************************************************/
/* EIBUFList: Деструктор на клас EIBUFList                                            */
/*  Входни данни :Няма                                                                       */
/*  Изходни данни:Няма                                                                       */
/***************************************************************************************/
 ElBUFList::~ElBUFList()
 {
    delete bl;//освобождаване на паметта от буфера
  }
  
/***************************************************************************************/
/* EIBUFList::operator new :Заделяне на памет за  данните на обект от този клас    */
/* Вход  :Размер на класа                                                                   */
/* Изход:Указател към заделената памет или NULL                                                */
/****************************************************************************************/
 void *ElBUFList::operator new (size_t size)
 { 
    void  *pr;              
    if(fNewMemory(&pr,size,&"ElBUfList") )
     return pr;
    else
      return pr=NULL;
 } 
     
  
 /***************************************************************************************/
/* EIBUFList ::operator delete:Освобождаване на паметта ,заделена за обект от   */
/*                                        този клас                                                               */
/* Вход  :Указател към заделената памет                                                           */
/* Изход:Няма                                               */
/****************************************************************************************/
 void ElBUFList::operator delete(void *ptr)
  { 
    FreeMemory(ptr);
  } 
  
       
/***************************************************************************************/
/* ListBUFList : Конструктор на клас ListBUFList.Създаване на списък от буфери */
/*  Входни данни : Няма                                                                             */
/*  Изходни данни:Няма                                                                       */
/***************************************************************************************/
  ListBUFList::ListBUFList()   
  {
     top=NULL;   //указател към първи елемент в списъка
     cur=&top;    //указател към текущ елемент                                                         
     ecur=&top;     //указател към текущ елемент                                            
     nm=0; //брой елементи
   }   
           
   
 /*********************************************************************/
/* ListBUFList::find:Търсене на елемент от списъка                  */
/* Вход  : Ключ за търсене-номер на буфер                    */
/* Изход : Няма .Намереният елемент се предава чрез текущия */
/*             указател cur,ако няма елемент *cur=NULL               */
/* Забележка:Работи се с указател cur                                    */
/**********************************************************************/
  void ListBUFList::findn(int num)
   {
      if(*cur==NULL)
         return;
      if((*cur)->numbz==num) /* проверка за номера */
          return;
      cur=&(*cur)->next;
      findn(num);  
   } 


/*********************************************************************/
/* ListBUFList::find:Търсене на елемент от списъка                  */
/* Вход  : Ключ за търсене-номер на буфер                    */
/* Изход : Няма .Намереният елемент се предава чрез текущия */
/*             указател cur,ако няма елемент *cur=NULL               */
/* Забележка:Работи се с указател cur                                    */
/**********************************************************************/
  void ListBUFList::find(int num)
   {
      if(*cur==NULL)
         return;
      if((*cur)->numb==num) /* проверка за номера */
          return;
      cur=&(*cur)->next;
      find(num);  
   } 

/*********************************************************************/
/* ListBUFList::find:Търсене на елемент от списъка                  */
/* Вход  : Ключ за търсене-номер на буфер                    */
/* Изход : Няма .Намереният елемент се предава чрез текущия */
/*             указател cur,ако няма елемент *cur=NULL               */
/* Забележка:Работи се с указател ecur                                    */
/**********************************************************************/
 void ListBUFList::finde(int num)
   {
      if(*ecur==NULL)
         return;
      if((*ecur)->numb==num) /* проверка за номера */
          return;
      ecur=&(*ecur)->next;
      finde(num);  
   } 

 /*********************************************************************/
/* ListBUFList::find:Търсене на елемент от списъка                  */
/* Вход  : Ключ за търсене-номер на буфер                    */
/* Изход : Няма .Намереният елемент се предава чрез текущия */
/*             указател cur,ако няма елемент *cur=NULL               */
/* Забележка:Работи се с указател ecur                                    */
/**********************************************************************/
 void ListBUFList::findez(int num)
   {
      if(*ecur==NULL)
         return;
      if((*ecur)->numbz==num) /* проверка за номера */
          return;
      ecur=&(*ecur)->next;
      findez(num);  
   } 


 /*********************************************************************/
/* ListBUFList::add :Добавяне на възел                                  */
/* Входни данни :Номер на буфер                                      */
/* Изход :Флаг                                                                 */
/*             FALSE -неуспешно добавяне                             */
/*             TRUE   -успешно                                                 */
/************************************************************************/
  flag ListBUFList::add( int num) 
   {    
      ElBUFList *work=NULL;
      permission=FALSE;        
      cur=&top;
      find(num);
      permission=TRUE;
      if(*cur)
        return FALSE;
      else
      {             
        work=new ElBUFList(num,nm+1);
        cur=&top;
        find(num);
         (*cur)=work;
          if(*cur)
          {
                  nm++;
                  return TRUE;
           }
           else
            return FALSE;  
      }
   }                                           
   
/*********************************************************************/
/* ListBUFList::addn :Добавяне на възел                                  */
/* Входни данни :Номер на буфер                                      */
/* Изход :Флаг                                                                 */
/*             FALSE -неуспешно добавяне                             */
/*             TRUE   -успешно                                                 */
/************************************************************************/
  flag ListBUFList::addn(int num) 
   {    
      ElBUFList *work=NULL;
      permission=FALSE;        
      int numz=nm+1;
      cur=&top;
      findn(numz);
      permission=TRUE;
      if(*cur)
        return FALSE;
      else
      {             
        work=new ElBUFList(num,numz);
        cur=&top;
        findn(numz);
         (*cur)=work;
          if(*cur)
          {
                  nm++;
                  return TRUE;
           }
           else
            return FALSE;  
      }
   }


 /*********************************************************************/
/* ListBUFList::removeall:Изтриване (унищожаване) на списъка */
/* Вход  : Начало на списъка                                            */
/* Изход : Няма                                                                 */
/**********************************************************************/
   void ListBUFList::removeall(ElBUFList **pcnc)
   {
     if(*pcnc==NULL)   //няма елементи
       return;
     removeall(&((*pcnc)->next));  //рекурсивно  извикване
     delete *pcnc;//изтриване на елемента 
     nm--;  //намаляване на брояча
     *pcnc=NULL; //указателя е NULL -не сочи елемент
   }

/***************************************************************************************/
/* ListBUFList ::eraseEIBUF : Изтриване на елемент с посочен ключ от списъка */
/* Вход  :Ключ на елемента - номер на буфер                                      */
/* Изход:Няма                                                                                         */
/* Забележка:Работи се с указател cur                                    */
/****************************************************************************************/
void  ListBUFList::eraseElBUF( int num)
{                
   ElBUFList *pcnc=NULL;
   ElBUFList *p=NULL;
   cur =&top; 
   find(num);
   if(!*cur)  /* не съществува */
     return ;
   else
   {        
     pcnc=*cur;
     if(!(*cur)->next) /* последен елемант */
     {   
        delete *cur;
        *cur=NULL;
        nm--;
     }
     else     /* не е последен */
     {      
        /* запомняне на указателите към предходния и следващия елемент */
        *cur=(*cur)->next;
         delete pcnc;  
         p=*cur;
         while(p)
          {   
              p->numbz--;
              p=p->next   ;
         }
        nm--;
     }       
   }
}

/***************************************************************************************/
/* ListBUFList ::eraeEIBUF : Изтриване на елемент с посочен ключ от списъка */
/* Вход  :Ключ на елемента - име на командата                                       */
/* Изход:Няма                                                                                         */
/* Забележка:Работи се с указател ecur                                    */
/****************************************************************************************/
void  ListBUFList::eraeElBUF( int num)
{                
   ElBUFList *pcnc=NULL;
    ElBUFList *p=NULL;
   ecur =&top;     
   finde(num);
   if(!*ecur)  /* не съществува */
     return ;
   else
   {        
     pcnc=*ecur;
     if(!(*ecur)->next) /* последен елемант */
     {   
        delete *ecur;
        *ecur=NULL;
        nm--;
     }
     else     /* не е последен */
     {      
        /* запомняне на указателите към предходния и следващия елемент */
        *ecur=(*ecur)->next;
         delete pcnc;
         p=*ecur;
         while(p)
          {   
               p->numbz--;
               p=p->next   ;
         }
        nm--;
     }       
   }
}
  
/***************************************************************************************/
/* ListBUFList ::eraeEIBUF : Изтриване на елемент с посочен ключ от списъка */
/* Вход  :Ключ на елемента - име на командата                                       */
/* Изход:Няма                                                                                         */
/* Забележка:Работи се с указател ecur                                    */
/****************************************************************************************/
void  ListBUFList::eraezElBUF( int num)
{                
   ElBUFList *pcnc=NULL;
    ElBUFList *p=NULL;
   ecur =&top;     
   findez(num);
   if(!*ecur)  /* не съществува */
     return ;
   else
   {        
     pcnc=*ecur;
     if(!(*ecur)->next) /* последен елемант */
     {   
        delete *ecur;
        *ecur=NULL;
        nm--;
     }
     else     /* не е последен */
     {      
        /* запомняне на указателите към предходния и следващия елемент */
        *ecur=(*ecur)->next;
         delete pcnc;
         p=*ecur;
         while(p)
          {   
               p->numbz--;
               p=p->next   ;
         }
        nm--;
     }       
   }
}
  

/***************************************************************************************/
/* ListBUFList ::L_get_last : Търсенe на последния елемент в списъка        */
/* Вход  :Няма                                                                                       */
/* Изход:Няма                                                                                         */
/****************************************************************************************/
 void ListBUFList::L_get_last()
 {
   if(*cur==NULL) /* ако няма елементи излиза */
    return ;
   if((*cur)->next==NULL) /* ако няма следващ излиза */
    return ;
   cur=&(*cur)->next; /* следващия */
   L_get_last();  /* рекурсивно извикване */
}

