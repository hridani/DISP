/********************************************************************/
/*          Описение на функциите включени в клас LSID              */
/********************************************************************/
 #include <conio.h>
 #include <dos.h>
 #include <stdio.h> 
 #include <stdlib.h>
 #include "..\include\lsid.h"
  #include "..\include\comv.h"
/*    Прототипи на функции  */
 long int readp( int );
 long int writep( int,long int );

/********************************************************************/
/*  ReadLS: Функцията чете стойността записана в CNTR,чрез OL */
/*  Входни  данни :Няма                                             */
/*  Изходни данни :Прочетената стийност                             */
/********************************************************************/
 long int LSID::ReadLS(void)
 {
   rr=readp(ad) ;  /* извиква функцията за четене,ad- адрес на порт */
   return  rr;
 }

/********************************************************************/
/*  WriteLS: Функцията записва стойност в CNTR,чрез PR   */
/*  Входни  данни :Стийността за запис                              */
/*  Изходни данни :Стойността,която е записана                */
/********************************************************************/
 long int LSID::WriteLS( long int pd )
 {
   rw=writep( ad,pd);/* извиква функцията за четене,ad-адрес на порт*/
   return  rw;
 }

/********************************************************************/
/*  Inicializacia: Функцията инициализира регистри MCR,ISR,OCCR,QR  */
/*  Входни  данни :Няма                                             */
/*  Изходни данни :Няма                                             */
/********************************************************************/
 void LSID::Inicializacia(void)
 {
   _outp(ac,0x20);                /* MSR                            */
   _outp(ac,0x80);                /* OCCR                           */  
   WriteLS(0x800000);
   _outp(ac,0x78);                /* ISR                            */     
   switch  (kv)                   /* QR                             */     
   {
     case 1:
      _outp( ac,193); 
      break;
     case 2:
      _outp( ac,194);  
      break;
     case 4:
      _outp( ac,195); 
      break;
   };
 }

/********************************************************************/
/*  LSID: Функция-конструктор                                    */
/*  Входни  данни :Няма                                             */
/*  Изходни данни :Няма                                             */
/********************************************************************/
 LSID::LSID(int ind,double mas,int kvk,long int k_d,int als)
 {                
   div_t d1;
   d1=div(ind,10);
   index=d1.rem;
   v_en=d1.quot;
   km=mas;
   kv=kvk;
   kd=k_d;      
   kf=(double)((km) / (kv * kd));  
   ad=als + (0x2*index - 0x2); 
   ac=ad+1; 
   rr=0;
   rw=0;
   status=0;
   next=NULL;
 } 

/********************************************************************/
/*  NLSID:Функция-конструктор                                     */
/*  Входни  данни :Няма                                             */
/*  Изходни данни :Няма                                             */
/********************************************************************/
NLSID::NLSID()
{
  top=0;
  cur=&top;
  nb=0;
}

/********************************************************************/
/*  ~NLSID:Функция-деструктор                                   */
/*  Входни  данни :Няма                                             */
/*  Изходни данни :Няма                                             */
/********************************************************************/
NLSID::~NLSID()
{
   removeall(&top);
}
/********************************************************************/
/*   Find:Търсене на възел по указаният номер (ключ)    */
/*  Входни  данни :Няма                                             */
/*  Изходни данни :Няма                                             */
/********************************************************************/
void NLSID::find (int number)
{ 
  if(*cur==NULL)
   return;
  if((*cur)->index==number)
    return;
  cur=&(*cur)->next;
  find(number);  /* Рекурсивно извикване */
}
 

/********************************************************************/
/*  add:Добавяне на възел                                          */
/*  Входни  данни :Няма                                             */
/*  Изходни данни :Няма                                             */
/********************************************************************/
 int NLSID::add(int ind,double mas,int kvk,long int k_d,int als)
 {
  int err=0;
  cur=&top;  /* Инициализация */
  find( ind );
  if(*cur)  /* Съществува  възел с указаното име */
    err=3;
  else
  {                                                  
     /* Създава нов възел:извикване на конструктор Nose */
    *cur=new LSID(ind,mas,kvk,k_d,als);
    nb++;
  }
  return err;
}

/********************************************************************/
/*  removeall:Изтриване на списъка с данни                */
/*  Входни  данни :Няма                                             */
/*  Изходни данни :Няма                                             */
/********************************************************************/
 void NLSID::removeall(LSID**p)
{
  if(*p==NULL)
    return;
  removeall(&((*p)->next));  // Изтриване на наследниците
  delete *p;    // Изтриване на началото
  nb--;
  *p=NULL;
 }
   

/********************************************************************/
/*  ROSR:Функция-извежда съдържанието на OSR за конкретния обект */
/*  Входни  данни :Няма                                             */
/*  Изходни данни :Съдържанието на OSR                              */
/********************************************************************/
 short  LSID::ROSR(void)
 {                      
   status=_inp(ac);
   return  status; 
 }   
      

/********************************************************************/
/*   readp: Функцията чете последователно 3-те байта на OL-регистъра      */
/*  Входни  данни :Адрес на порт ,откъдето се чете                  */
/*  Изходни данни :Съдържанието на OL                               */
/********************************************************************/
 long int readp(int ap)
 {
   byte r1,r2,r3;
   long int r;
   r=0x0000000;
   _outp((ap+1),3);               /* командна думa за MCR           */
   r3=_inp(ap);                   /* младши байт                    */
   r2=_inp(ap);
   r1=_inp(ap);                   /* старши байт                    */
   r=(long)((0x10000) * r1) + ((long)(0x100) * r2) +(long)r3;
   return r;
 } 


/********************************************************************/
/*  writep:Функцията пише  последователно  в 3-те байта на RP-регистъра    */
/*  Входни  данни :Адрес на порт,чрез който се записва и стойността */
/*  Изходни данни :Записаната стойност                              */
/********************************************************************/
 long int writep(int ap,long int dw)
 {
   byte r1,r2,r3,con1,con2,con3;
   long int con;
   con=0x0000000;
   r3=(byte) (dw/(0x10000));      /* старши байт                    */
   r2=(byte) (( dw-((long)r3*(0x10000)))/(0x100)) ;
   r1=(byte) (dw-(r3*(0x10000))-(r2*(0x100))); /* младши байт       */
   _disable();
    _outp((ap+1),1);               /* командна думa за MCR           */
   con1=_outp(ap,r1);             /* младши байт                    */
   con2=_outp(ap,r2);
   con3=_outp(ap,r3);             /* старши байт                    */
   _enable();
   _outp((ap+1),9);               /* командна думa за MCR           */
   con = ( (long)(0x10000) * con3 ) + ((long)(0x100)*con2) + con1;
   return con;
 }
