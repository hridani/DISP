/*****************************************************************************/
/*                            K E Y . C P P                                               */
/*  Описание на функционалните клавиши,списък на функц. кл   */
/*  инициализиране на клавиатурни буфери                                  */
/*******************************************************************************/
#include <dos.h>
#include "..\include\key.h"    
#include "..\include\memnew.h"
#include <string.h>
		      
/*********************************************************************/
/* IniBuffer: Заделяне памет за клавиатурен буфер           */
/* Вход  : Указател към буфера,размер                                            */
/* Изход : Няма                                                                 */
/**********************************************************************/
void IniBuffer(KeyBuffer *pkb,int size)
{                 
  if(fNewMemory((void **)(&pkb->scanbuf),size,&"KeyBuffer")!=FALSE)//заделяне на памет
  {
      pkb->scanend=pkb->scanbuf+size; //иниц. на указателя за край на буфера
      pkb->scanlast=pkb->scannext=_FP_OFF(pkb->scanbuf);//иниц. на указателите за последно прочетен
				    // и последно влязъл символ
  }
  
} 

/*********************************************************************/
/* EndBuffer: Освобождаване на  памет за клавиатурен буфер           */
/* Вход  : Указател към буфера                                            */
/* Изход : Няма                                                                 */
/**********************************************************************/
void EndBuffer(KeyBuffer *pkb)
{
     FreeMemory(pkb->scanbuf);//освобождаване на паметта
}

/**********************************************************************************************/
/* FuncKey::FuncKey:Конструктор на класс FuncKey-описание на функц.клавиш */
/* Вход : Име на функц. кл.,указател към функцията на клавиша и                  */
/*            указател към CR функция                                                                  */
/* Изход:Няма                                                                                                  */
/**************************************************************************************************/
FuncKey::FuncKey(char *nm,TC ac,TC cra)
{             
    int len=strlen(nm);
    name=new char [len +1];//заделяне на памет за име 
    strcpy(name,nm);  //име             
    *(name+len)='\0';
    activf=ac; //указател към функцията
    crfunc=cra;//указател към CR функцията
}

/**********************************************************************************************/
/* Key::Key:Конструктор на класс Key-описание на функц.клавиш като елемент*/
/* Вход : Указател към дефиниран финкц. клавиш                                            */
/* Изход:Няма                                                                                                  */
/**************************************************************************************************/
Key::Key(FuncKey *fk)
{
     funck=fk;//указтел към обект от клас FuncKey- funkc. kl.
     number=0;//номер
     next=NULL; //следващ елемент
}
      




/**********************************************************************************************/
/* ListKey::ListKey:Конструктор на класс ListKey-списък на функц. кл           */
/* Вход : Няма                                                                   */
/* Изход:Няма                                                                                                  */
/**************************************************************************************************/
ListKey::ListKey()
{
  top=NULL; //указател кум началото
  cur=&top; //указател към текущ елемент
  nm=0; //брой елементи
}

/*********************************************************************/
/* ListKey::find:Търсене на елемент от списъка                  */
/* Вход  : Ключ за търсене -указател към функц. кл.        */
/* Изход : Няма                                                                 */
/**********************************************************************/
void ListKey::find(FuncKey *fk)
{
      if(*cur==NULL)    //край на списъка
	 return;
      if((*cur)->funck==fk) //съвпадение
	 return;
      cur=&(*cur)->next; //следващ елемент
      find(fk);  //рекурсивно извикване
} 

/*********************************************************************/
/* ListKey::find:Търсене на елемент от списъка                  */
/* Вход  : Ключ за търсене -номер на функц. кл.        */
/* Изход : Няма                                                                 */
/**********************************************************************/
void ListKey::find(int nm)
{
      if(*cur==NULL)//край на списъка
	 return;
      if((*cur)->number==nm) //съвпадение
	 return;
      cur=&(*cur)->next; //следващ елемент
      find(nm);    //рекурсивно извикване
} 

/*********************************************************************/
/* ListKey::add :Добавяне на възел със зададено име      */
/* Вход  : Указател към функц. кл                                     */
/* Изход :Флаг                                                                 */
/*            FALSE  - не е добавен елемента в списъка        */
/*            TRUE - не е добавен елемента в списъка            */
/************************************************************************/
flag ListKey ::add(FuncKey *fk)
{
      cur=&top;
      find(fk);//търсене на функц. кл. в списъка
      if(*cur) //има такъв клавиш
	   return FALSE;
      else  //няма
      {
	*cur=new Key(fk);    //добавяне в края на списъка
	nm++;                   //брай на елементите
	(*cur)->number=nm; //иниц. на номера на функц.кл
	return TRUE;
      }
}


/*********************************************************************/
/* ListKey::add :Добавяне на възел със зададено име    ,подредба по номер  */
/* Вход  : Указател към функц. кл                                     */
/* Изход :Флаг                                                                 */
/*            FALSE  - не е добавен елемента в списъка        */
/*            TRUE - не е добавен елемента в списъка            */
/************************************************************************/
flag ListKey ::add(FuncKey *fk,int nmf)
{                       
     FuncKey *work=NULL;
     FuncKey *work1=NULL;
      cur=&top;
      find(fk);//търсене на функц. кл. в списъка
      if(*cur) //има клавиш с този номер 
	return FALSE;
      else  //няма
      {
	*cur=new Key(fk);    //добавяне в края на списъка
	nm++;                   //брой на елементите
	(*cur)->number=nm; //иниц. на номера на функц.кл

	      cur=&top;
	     find(nmf);//търсене на функц. кл. в списъка
	     if(*cur)
	     {
	      work1=fk;
		 while(*cur)
		 {
		       work=(*cur)->funck;
				(*cur)->funck=work1;
				work1=work;
		       cur=&(*cur)->next; //следващ елемент
	     }
	   }

      }
	      return TRUE;
}


/*********************************************************************/
/* ListKey::removeall:Изтриване (унищожаване) на списъка */
/* Вход  : Начало на списъка                                            */
/* Изход : Няма                                                                 */
/**********************************************************************/
void ListKey::removeall(Key **pcnc)
{
     if(*pcnc==NULL)
       return;
     removeall(&((*pcnc)->next));// Изтриване на наследниците 
     delete *pcnc;// Изтриване на началото
     nm--;
     *pcnc=NULL; 
}

/***************************************************************************************/
/* ListKey ::eraseKey : Изтриване на елемент с посочен ключ от списъка */
/* Вход  :Ключ на елемента -указател към дефиниран функционален клавиш*/
/* Изход:Няма                                                                                         */
/****************************************************************************************/
void  ListKey::eraseKey(FuncKey *fk)
{                
   Key *pfk=NULL;
   cur =&top; 
   find(fk);
   if(!*cur)  /* не съществува */
     return ;
   else
   {        
     pfk=*cur;
     if(!(*cur)->next) /* последен елемант */
     {   
	delete *cur;
	*cur=NULL;
	nm--;
     }
     else     /* не е последен */
     {      
	/* запомняне на указателите към предходния и следващия елемент */
	*cur=(*cur)->next;
	 delete pfk;
         while(*cur)
          {   
               (*cur)->number=(*cur)->number-1;
              cur=&(*cur)->next; //следващ елемент
         }

	nm--;
     }
   }
}

