/****************************************************************************************/
/*                                 C L A S S T H . C P P                                          */
/*      Описание на задача на "DISP" и списък от задачи                                          */
/****************************************************************************************/
#include <malloc.h>  
#include <string.h>
#include <stdlib.h>
#include <dos.h>       
#include "..\include\classth.h"
#include <stdio.h>
#include <new.h>                                                   
#include "..\include\svga.h"
    

  //промяна в дефиницията на ExitSys , заради включване на вариант за работа с различни таймери, прекъсвания    5.01.2011-(задача automat)

//extern void ExitSys(void);// освобождава памет ,връща векторите на прекъсване      - за DISP от платка Иван или само един вариант

extern TC ExitSys;// освобождава памет ,връща векторите на прекъсване       - за два варианта, определяне , чрез параметър N30
unsigned uoldss,uoldsp; //старите стойност на регистри ss,sp
unsigned unewsp,unewss,unewcs,unewip; //помощни променливищ
unsigned uexitcs,uexitip;//помощни променливи
extern flag permission;

/***************************************************************************************/
/* EXITTASK : Изход от задача на "DISP".Адресът  на  тази функция се */
/*                   намира  в началото на стека на всяка задача на "DISP"    */
/*  Входни данни :Няма                                                                           */
/*  Изходни данни:Няма                                                                       */
/***************************************************************************************/
void EXITTASK(void)
{
   ExitSys(); //освобождава памет ,връща векторите на прекъсване
   __asm
   {
	 cli
	 mov ss,uoldss //връща старите стойности /начални / на регистри ss ,sp
	 mov sp,uoldsp
	 sti
   }
   exit (0);
}



/***************************************************************************************/
/* TaskHandel : Конструктор на клас TaskHandle.Описание на задача, */
/*                    заделяне на памет за стек,попълване на начална информация*/  
/*                     в стеака                                                                             */
/*  Входни данни :Име на задачата,състояние,приоритет,вид ,време /за период. задачи / */
/*                         размер на стека,функция на задачата                                */
/*  Изходни данни:Няма                                                                       */
/***************************************************************************************/
 TaskHandle::TaskHandle(char *nm,State stt,unsigned pr,Kind kn,unsigned long tm,unsigned stsize,TC tc)
 {     
    void *p=EXITTASK;//функция за изход
    st=stt;         //състояние 
    priority=pr;   //приоритет
    kind=kn;      //вид
    time =tm;    //време,при периодичните задачи                             
    timec=time; //брояч на времето ,при периодичните задачи
    taskcode=tc; //указател към функция      
    taskcond=NULL; //указател към лог. уравнение за активност ,при задачи,чакащи условие/условия
    name=new char [strlen(nm) +1]; //заделяне на памет за име
    strcpy(name,nm);     //име
    bstack=NULL;
    if(kind==Slow)  // заделяне памет за стек само на бавните задачи
    {
    if(fNewMemory((void **)(& bstack),stsize,&"StackTask")!=FALSE) //размер на стека
    // if(NewMemory((void **)(& bstack),stsize)!=FALSE) //размер на стека
    {                                                //има памет
	unewsp=_FP_OFF(bstack) + stsize;//края на заделената област-начало на стека
	ucurss=unewss=_FP_SEG(bstack); //сегмент на стека
	unewcs=_FP_SEG(tc); //стойностите на рег, cs,ip се определят от указателя на функцията  tc
	unewip=_FP_OFF( tc);
	uexitcs=_FP_SEG(p); //стойностите на рег. cs,ip /използуват се при изход/ се 
	uexitip=_FP_OFF(p); //определят от указателя на функцията за изход    
	
	__asm
	{
	 mov uoldsp,sp //съхраняване на информацията за текущи стойност на стека
	 mov uoldss,ss
	 cli
	 mov sp,unewsp  //регистри ss,sp се иниц. с новия стек
	 mov ss,unewss
	 sti
	 push uexitcs  //запис в новия стек адреса на функцията за изход EXITTASK
	 push uexitip
	 push sp      //съхраняване на sp,di,si
	 push di
	 push si

	 pushf  //запис в стека на флаговия регистър
	 push unewcs//запис в стека на адреса на функцията на задачата
	 push unewip
	 pusha         //запис на останалите регистри 
	 push ds      //запис на ds ,es
	 push es
	 mov unewsp,sp  //запомняне на дълбочината на стека
	 cli
	 mov ss,uoldss //връщане на старите стойности на стека,това е стека на функция MAIN
	 mov sp,uoldsp
	 sti
      }  
      ucurbp=ubeginbp=unewsp;
    }       
    else
	   ucurbp=ubeginbp=0;    
    } 
    else
       ucurss=ucurbp=ubeginbp=0;        
  }

     
unsigned brtt;
TaskHandle::~ TaskHandle(void)
{    
  brtt++;
  
    delete name;
    if(bstack!=NULL)
     FreeMemory(bstack);
    if(taskcond!=NULL)
       delete taskcond;
//    sprintf(buffer,"TASK %s %d ",this->name,brtt);
//  printf(buffer);
}

/***************************************************************************************/
/* ItemTask : Конструктор на клас IteмТask.Описание на задача,           */
/*                  като възел от списък                                                        */
/*  Входни данни : Указател към задачата ,указател към предходния възел*/
/*  Изходни данни:Няма                                                                       */
/***************************************************************************************/
 ItemTask::ItemTask(TaskHandle *pth,ItemTask *bp)
  {
     th=pth; //указател към задачата //трябва да е дефинирана
     next=NULL;//следващ възел =NULL   
     back=bp;//указатекл към предходен възел
  }
  
  
/***************************************************************************************/
/* StateList : Конструктор на клас StateList.Създаване на списък от задачи  */
/*                 или обекти от клас ItemTask                                                        */
/*  Входни данни : Няма                                                                             */
/*  Изходни данни:Няма                                                                       */
/***************************************************************************************/
 StateList::StateList()   
  {
     top=NULL; //указател към първи елемент в списъка
     cur=&top; //указател към текущ елемент                
     bcur=top; //ъказател към последен елемент
     nm=0; //брой елементи
   }   
	   
/*********************************************************************/
/* StateList::find:Търсене на елемент от списъка                  */
/* Вход  : Ключ за търсене-указател към задача                  */
/* Изход : Няма .Намереният елемент се предава чрез текущия */
/*             указател cur,ако няма елемент *cur=NULL               */
/**********************************************************************/
   void StateList::find(TaskHandle *pth)
   {
      if(*cur==NULL) //край на списъка
	 return;
      if((*cur)->th==pth) //намерен е елемента
	 return;                   
      bcur=*cur;  /* указател към последния елемент */         
      cur=&(*cur)->next;//следващ елемент
      find(pth);   //рекурсивно извикване 
   } 

/*********************************************************************/
/* StateList::add :Добавяне на възел със зададен указател кум задача */
/* Вход  : Указател към задачата за добавяне в списъка                        */
/* Изход :Флаг                                                                 */
/*             FALSE -неуспешно добавяне                             */
/*             TRUE   -успешно                                                 */
/************************************************************************/
  flag StateList::add(TaskHandle *pth)
   {
      if(pth==NULL)
	return FALSE;
      cur=&top; //иниц. на текущия указател 
      find(pth);  //търсене на задачата в списъка  -дали не записана преди
      if(*cur) //има -изход
	   return FALSE;
      else //няма
      {
	*cur=new ItemTask(pth,bcur);     //заделяне на памет и създаване на възел ItemTask
	if(*cur!=NULL) // създаден е възела     
	{
	 nm++; //увеличаване на брояча -елементи в списъка
	 return TRUE;
	 }
	 else
	   return FALSE;                        
      }
   }

/*********************************************************************/
/* StateList::removeall:Изтриване (унищожаване) на списъка */
/* Вход  : Начало на списъка                                            */
/* Изход : Няма                                                                 */
/**********************************************************************/
  void StateList::removeall(ItemTask  **pit)
   {
     if(*pit==NULL)  //няма елементи
       return;
     removeall(&((*pit)->next)); //рекурсивно извикване 
     delete (*pit)->th;
     delete *pit; //изтриване на елемента 
     nm--; //намаляване на брояча
     *pit=NULL;  //указателя е NULL -не сочи елемент
   }

/***************************************************************************************/
/* StateList ::eraseTask : Изтриване на елемент с посочен ключ от списъка */
/* Вход  :Ключ на елемента -указател към задача                                       */
/* Изход :Флаг                                                                 */
/*             FALSE -неуспешно изтриване                             */
/*             TRUE   -успешно                                                 */
/************************************************************************/
flag  StateList::eraseTask(TaskHandle *pth)
{                
   ItemTask *pit; //помощен указател
   flag flag_result=FALSE;
   cur =&top;  //иниц. на текущия указател
   find(pth); //търсене на задачата
   if(!*cur)  /* не съществува */
     return FALSE;
   else
   {        
     if(permission==FALSE)
       return FALSE;
     pit=*cur; //запомнчне на адреса на задачата
     if(!(*cur)->next) /* последен елемeнт */
     {    
		delete *cur;  //изтриване на задачата 
		*cur=NULL;
	 nm--; //намаляване на брояча
     }
     else     /* не е последен */
     {      
		/* запомняне на указателите към предходния и следващия елемент */
		*cur=(*cur)->next;//следващ елемент
	    delete pit;//изтриване на задачата
		nm--; //намаляване на брояча
     }
     return TRUE;
   }
}

/***************************************************************************************/
/* StateList ::saveall : Запис на списъка във файл с посочено име             */
/* Вход  :Име на файла                                                     */
/* Изход:Няма                                                                                         */
/****************************************************************************************/
void  StateList::saveall( char *nf )
{    
   FILE *f; //поток на файла
   ItemTask *p=top; //помощен указател  
   if(p) //докато име елементи в списъка -обхождане
   {
      f=fopen(nf,"w+t");  /* отваряне на файла - създаване */
      if(f==NULL)  //няма файл 
	 return ;//изход 
      else
      {
	fprintf(f,"%d",nm);  /* запис на   брой полета */
	saveList(f,top);   //запис на първия елемент  -рекурсивно запис на останалите
	fclose (f); //затваряне на файла
	 return ;
      }
   }
   else
    return ;
}
  
/***************************************************************************************/
/* StateList ::saveList : Запис на елемент  във файл с посочено име             */
/* Вход  :Име на файла ,указател към елемента                                           */
/* Изход:Няма                                                                                         */
/****************************************************************************************/
void StateList::saveList(FILE *f,ItemTask*p)
{
  if(p)
  {   
  /* запис на данните във файла по тип на полето */
    fprintf(f," %lp %lp %s %d %lp \n",p,p->th,p->th->name,p->th->st,p->next);//адрес ,име,състояние,указател към следващия ел.
      saveList(f,p->next); /* рекурсивно извикване */
   }
}     
  
/***************************************************************************************/
/* StateList ::L_get_last : Търесен на последния елемент в списъка        */
/* Вход  :Няма                                                                                       */
/* Изход:Няма                                                                                         */
/****************************************************************************************/
 //void StateList::L_get_last()
 void L_get_last(void)
{
 //  if(*cur==NULL) /* ако няма елементи изход */
    return ;
   //if((*cur)->next==NULL) /* ако няма следващ излиза */
    return ;
   //cur=&(*cur)->next; /* следващия */
   //L_get_last();  /* рекурсивно извикване */
}

ItemTask::~ItemTask()
{
  return;
}
