/******************************************************************************************/
/*                               D I S P N E W . C P P                                                 */
/*   Дефиниране на функции за работа с "DISP"  и на "DISP"                       */
/******************************************************************************************/
#include <dos.h>   
#include <conio.h>
#include <stdlib.h>
#include <string.h>
#include <graph.h>      
#include <math.h>
#include "dispnew.h"
#include "irq9new.h"          
#include "c:\msvc\dani\include\table.h"
#include "c:\msvc\dani\string.h"   
#include "c:\msvc\dani\comst.h"
#include "c:\msvc\dani\comn4.h"
#include "c:\msvc\dani\klabcnc.h"   
#include "c:\msvc\dani\include\svga.h"
#include "c:\msvc\dani\include\videoc.h"  
void (__cdecl __interrupt *oldb)();  /* вектор на прекъсване 0xb */
unsigned long brs; /* брой изпълнения */
TaskHandle *pcurold; /* помощна променлива за текуща задаяа */
TaskHandle *curmove;
TaskHandle *curpr;
char buffer[20]; /* помощен буфер */
extern List input; //списък на входовете 
flag flag_pr=TRUE;
flag flag_fC=FALSE;
flag flag_newcur=FALSE;
flag flagpr=FALSE;
 flag flag_firstXZ=FALSE; //избране е една от високо-приоритетните задачи
char * failsafe = new char[128];
NodeT *lw;
void DelTask(void);
int numbinp;//номер на хардуерно прекъсване,използувано от "DISP"
/***************************************************************************************/
/*  handle_program_memory_depletion: Извежда съобщение при недостиг на ОП */
/*  Входни данни : Размер на свободната памет                                                 */
/*  Изходни данни: Код на  завършване на програмата                                        */
/***************************************************************************************/
int handle_program_memory_depletion( size_t size )
{
   char buf[6]; //помощен буфер
   delete failsafe; // освобождаване на символен буфер в паметта
   dprint(0,1,1,0x70,& "Allocation failed,bytes not available " );//предупредителен текст
   UnsToStr((unsigned int)size,buf); //размер 
   dprint(0,1,2,0x70,buf ); //печат на свободната памет
   return 0;
}  




/*******************************************************************************************************/
/* TaskHandle : Създава дескриптор на задача - описание и стойности на                  */
/*                     необходимите данни                                                                          */
/* Входни данни: Име на задачата,състояние,приоритет,вид,време на периодичните  */
/*                        задачи,стек,функция,дескриптор на бавна задача,указател към       */
/*                        услловието на блокираните задачи                                                  */
/* Изходни данни:Указател към паметта с данни - дескриптор на задачата                  */
/*******************************************************************************************************/
TaskHandle*  CreateTask(char *nm,State stt,unsigned pr,Kind kn,unsigned long tm,unsigned stc,
			 TC tc,int *taskc)
{    
   TaskHandle *pth=new TaskHandle(nm,stt,pr,kn,tm,stc,tc); /*описание на задачата ,рез клас TASKHANDLE */
   switch (stt)  /* разделение по състояние */
   {
       case Current:  /* текуща */
	 CURTASK=pth;
       break;
       case Ready:  /* готова */
	 if(kn==Slow) /* бавна */
	   READYS.add(pth); /* добавяне в списъка на бавните готови задачи */
	 else
	   READYF.add(pth);  /* добавяне в списъка на бързите готови задачи */
       break;                           
       case Wait: /* чакаща условие */
	 WAIT.add(pth);    /* добавяне в списъка на чакащите задачи */
	 pth->taskcond=taskc; /* инициал. на условието за активност */
	 break;
       case Timed:
	 DELAY.add(pth);   /* добавяне в списъка на периодичните задачи */
       break;
       case Suspend:
	 SUSPEND.add(pth);   /* добавяне в списъка на периодичните задачи */
	 if(taskc!=NULL)
	  pth->taskcond=taskc; /* инициал. на условието за активност */ 
       break;
     }
     return pth; /* връща указател към описаната задача в паметта - обект от клас TaskHandle */
}        
    
      
      
/*******************************************************************************************************/
/* ExitSys :Изход от системата - изключва изходи,спира таймера,възстановава         */
/*              старите вектори на прекъсване  ...                                                             */
/* Входни данни:Няма                                                                                                */
/* Изходни данни :Няма                                                                                             */
/*******************************************************************************************************/
void ExitSys(void)
{
       EndKeyb(); /* освобождава паметта от клавиатурните буфери,връща стъария вектор на кл.прек. */
       byte numbv=8+numbinp;
	      _dos_setvect(numbv,oldb);/* стр вектор на прекъсване 0xb ,използувано от "ДИСПЕЧЕРА " */  
       FreeMemory(tsem);      

       SetScreenPage(0);
       OutTimer(0x120);
    	printf("END   SYSTEM  !!!");
	  
}

/*******************************************************************************************************/
/* EndTask :  Функцията подготвя за изход от програмата ,                                          */
/*                  извиква се от задача предизвикала изхода                                              */
/* Входни данни:Няма                                                                                                */
/* Изходни данни :Няма                                                                                             */
/*******************************************************************************************************/
void EndTask(void)
{ 
    if(CURTASK !=NULL) /* има ли текуща задача */
   {
       pcurold=CURTASK; /* помощен указател */
    __asm
    {         
      les bx,pcurold                     //този блок търси началото на стека,който е създаден за тази задача
      mov sp,es:[bx].ubeginbp    //  В това начало е записана информациа ,чрез която може да се
      add sp,26                          // направи преход в главната програма ->изход  в DOS 
      mov bx,sp
      add bx,4
      mov bp,bx
   }
 }  
}

/*========================================================*/
/*  MeasTime:Изчисляване на оставащото до стартиране време на време    */
/*                  чакащите задачи                                                                     */
/*  Входни данни: Няма                                                                               */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void MeasTime(void)
{    
   TaskHandle *pr=NULL; // помощен указател за задача
   flag old_pr=flag_pr;
   flag_pr=FALSE;
   DELAY.cur=&DELAY.top; /* списък на време чакащи задачи */
   while(*DELAY.cur)  // има ли чакащи задачи 
  { 
      pr=(*DELAY.cur)->th;  /*  задача  с изтекло време */
      pr->timec--;  /* намаляване на времето на време чакащи задачи */
      if(pr->timec==0) /* задачи с време 0 ?*/
      {                                     
	     if(pr->kind==Slow)  /* бавни ? */
	     {
		  if(READYS.add(pr)!=FALSE) /* добавяне в списъка на бавните,ако е възможно */
		  {
			pr->st=Ready;  /* промяна на състоянието TIMED - READY */
			if(pr->priority>20)
			{                          
			  flagpr=TRUE;//да се из пълни задачата с висок приоритет
			}
			if(DELAY.eraseTask(pr) ==FALSE) /* изтриване от списъка на чакащите време */
			  pr->st=Timed;
//                        CURTASK->timec=CURTASK->time; /* настройка на брояча за време */
		  }
		  else /* невъзможно да се включи в списъка на готовите - прекъснатата задача работи с паметта */
		  {   
			(*DELAY.cur)->th->timec++; /* да се провери през следващия такт */
			DELAY.cur=&(*DELAY.cur)->next; /* следваща задача */
		  }
	     }
	    else  /* остават - бързи */
	    {
	       if( READYF.add(pr)!=FALSE) /* добавяне в списъка на бързите */
	     {
			pr->st=Ready;           /* промяна на състоянието TIMED - READY */
			DELAY.eraseTask(pr); /* изтриване от списъка на чакащите време */
	       }
	       else /* невъзможно да се включи в списъка на готовите - прекъснатата задача работи с паметта */
	     {   
		   (*DELAY.cur)->th->timec++;  /* да се провери през следващия такт */
			DELAY.cur=&(*DELAY.cur)->next; /* следваща задача */
	    }
	}
	if(!*DELAY.cur) /* ако последната задача в списъка е вече в друг списък */
	    break;
     }
     else
	    DELAY.cur=&(*DELAY.cur)->next; /* следваща задача */
   }     
   flag_pr=old_pr;
}
	
/*========================================================*/
/*  StartFast:Стартиране на бързите задачи на диспечера                            */
/*  Входни данни: Няма                                                                               */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void StartFast(void)
{       
      TaskHandle *curold=NULL;  // помощен указател за задача
      curold=CURTASK;       /* текуща задача - бавна ,запомня се*/
      READYF.cur=&READYF.top; /* списък на бързите задачи */
      while(*READYF.cur)  // има ли задачи в списъка 
      {                           
	 CURTASK=(*READYF.cur)->th; /* нова текуща - бърза */  
	 CURTASK->taskcode();/* код на задачата - изпълнение */
	 if(!(*READYF.cur)) /* ако последната от списъка не е преминала в друга група */
	  break;                                                 
	if(CURTASK == (*READYF.cur)->th)
	  (READYF.cur)=&(*READYF.cur)->next; /* следващата задача в списъка */
      }
      CURTASK=curold; /* връщане към старата CURTASK задача */
}     


/*========================================================*/
/*  FindSlow:Търсене на следващата бавна задача и стартиране                  */
/*  Входни данни: Няма                                                                               */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void  FindSlow(void)
{                             
  TaskHandle *pr=NULL; //помощен указател 
  unsigned ucurpr=0; /* най - висок приоритет от разглежданите задачи */
  flag old_pr=flag_pr;
  flag_pr=FALSE;
  if(CURTASK && CURTASK->st==Current)     /* има текуща задача,започва се сравнение с нейния приоритет */
    ucurpr=CURTASK->priority; /* приоритет на текущо изпълняваната задача */
  READYS.cur=&READYS.top; /* списък на бавните задачи */
   while(*READYS.cur)  /* докато има задачи */
  {     
	  if((*READYS.cur)->th->priority >ucurpr) /* определяне приритета на бавната задача > от CURRENT*/
	  {
	     pr=(*READYS.cur)->th;/* кандидат за текуща задача */
	     ucurpr=pr->priority; /* нов текущ приоритет */
	  }                                              
	  (READYS.cur)=&(*READYS.cur)->next; /* следваща задача */
   }                                                                         
    
   if(pr) /* има ли текуща - при първо извикване - няма */
   {
       if(CURTASK && CURTASK->st==Current)
	       CURTASK->st=Ready; /* промяна на състоянието  на досегашната CURRENT*/
      CURTASK=pr; /* новата CURTASK задача  групата на готовите бавни*/            
      CURTASK->st=Current; /* промяна на състоянието */
   }
   flag_pr=old_pr;
   } 

/*========================================================*/
/*  Delay: Промана  на състоянието на CURTASK задача                             */
/*  Входни данни: Няма                                                                               */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void  Delay(void)
{    
   CURTASK->st=Timed; /* промяна на състоянието в Timed*/
   if(CURTASK->kind==Slow)     /* бавна ? */
    whlt(); /* спира ,докато "DISP" избере нова текуща задача */
   else
   {   /* бързи */
       READYF.eraseTask( CURTASK);  /* изтрива се от списъка на готовите бързи  */
       DELAY.add(CURTASK); /* добавяне в списъка на чакащите време */
       CURTASK->timec=CURTASK->time; /* настройка на брояча за време */
  }

  
}

/*========================================================*/
/*  CurDelay: Преминаване на CURTASK задача/ бавна / в спиъка на чакащите време  */
/*  Входни данни: Няма                                                                               */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void CurDelay(void)
{
   CURTASK->timec=CURTASK->time; /* настройка на брояча за време */
   if(READYS.eraseTask( CURTASK)!=FALSE) /* изтриване ит списука на готовите бавни */
     DELAY.add(CURTASK);/* добавяне в списъка на чакащите време */
}

/*========================================================*/
/*  NewSuspend: Промяна  на състоянието на указаната задача във SUSPEND */
/*                             (временно неактивна  )                                               */
/*  Входни данни: Указател към задачата                                                                         */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void  NewSuspend(TaskHandle *pth)
{                        
   if(pth==NULL)
     return;
  flag old_pr=flag_pr;                                                                                                                             
  flag_pr=FALSE;
    SUSPEND.add(pth); //запис в списъка на неактивните задачи                           
    READYS.cur=&READYS.top;
    READYS.find(pth);  //търсене в списъка на готовите
    if(*READYS.cur)
       READYS.eraseTask(pth);
    else
    {
       DELAY.cur=&DELAY.top;
       DELAY.find(pth);
       if(*DELAY.cur)
			DELAY.eraseTask(pth);
       else
       {   
			WAIT.cur=&WAIT.top;
			WAIT.find(pth);
			if(*WAIT.cur)
			WAIT.eraseTask(pth);     
			else
			{
	    //no task
		     READYF.cur=&READYF.top;
		 READYF.find(pth);  //търсене в списъка на готовите
		 if(*READYF.cur)
		   READYF.eraseTask(pth);
			}
       }
    }
    if(pth!=NULL)
    {
    if(pth->st==Current)
    {  
       pth->st=Suspend; 
       if(CURTASK->priority>20 && flag_newcur==TRUE)
			 flag_fC=TRUE;
       if(CURTASK->priority >20)
       {                                                
			flagpr=FALSE;// няма задача с висок приоритет
		  flag_firstXZ=FALSE;
      }
       flag_change=TRUE;
       flag_pr=old_pr;
       whlt();
    }
    else
      pth->st=Suspend; 
      flag_pr=old_pr;
    }
}

/*========================================================*/
/*  Resume: Промяна  на състоянието на указаната задача от SUSPEND */
/*                             (временно неактивна  )  търсено предходно                           */
/*  Входни данни: Указател към задачата                                            */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void  Resume(TaskHandle *pth)
{    
   flag old_pr=flag_pr;                       
    flag_pr=FALSE;
    //__asm cli;
    SUSPEND.cur=&SUSPEND.top;
    SUSPEND.find(pth);
    if(!*SUSPEND.cur)
    {
      flag_pr=old_pr;
    //  __asm sti;
      return;
    }
    if(pth->taskcond!=NULL)
    {
       WAIT.add(pth);                                                                                                                         
       pth->st=Wait;
    }
    else
    {
      if(pth->time!=0  && pth->timec!=0)
      {
		DELAY.add(pth);
		pth->st=Timed;
       }
       else
       {
			READYS.add(pth);
			pth->st=Ready;
	}
      }
      SUSPEND.eraseTask(pth);
      flag_pr=old_pr;
      //__asm sti;
}

/*========================================================*/
/*  FindSem : Проверка за настъпване на събитията ,очаквани от дадени задачи */
/*  Входни данни: Няма                                                                               */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void FindSem(void)
{    
   TaskHandle *pth=NULL;// помощен указател
   flag old_pr=flag_pr;
   flag_pr=FALSE;
   WAIT.cur=&WAIT.top; /* иниц. на текущия указател от списъка на чакащите */
   while(*WAIT.cur)  /* обхогдане на списъка от  чакащи задачи */ 
   {
       pth=(*WAIT.cur)->th; /* иниц. на помощния указател с разглежданата задача */
       if(check_con(pth->taskcond)!=FALSE ) /* проверка дали е настъпило събитието */
       {    /* да */
	    if(pth->kind==Slow)  /* бавни ? */
	    {
	    if( READYS.add(pth)!=FALSE)              /* добавяне в списъка на бавните */
	    {   
	       WAIT.eraseTask(pth); /* изтриване от списъка на чакащите условие*/
			pth->st=Ready; /*промяна на  състовнието- READY */
	      }
	      else /* невъзможхост за добавяне - работи се с паметта */
	       WAIT.cur=&(*WAIT.cur)->next; /* следваща задача */
       }
	 else  /* остават - бързи */
	 {
	     if( READYF.add(pth)!=FALSE) /* добавяне в списъка на бързите */
	    {   
	       WAIT.eraseTask(pth); /* изтриване от списъка на чакащите условие*/
			pth->st=Ready; /* задачата е в състовние READY */
	      }
	      else /* невъзможхост за добавяне - работи се с паметта */
		  WAIT.cur=&(*WAIT.cur)->next;  /* следваща задача */
	 }  
	 if(!*WAIT.cur) /* последна задача в списъка */
	    break;           
     }
     else
       WAIT.cur=&(*WAIT.cur)->next;/* следваща задача */
   }     
   flag_pr=old_pr;
}

/*========================================================*/
/*  WaitCond: Промана  на състоянието на CURTASK задача в чакаща събитие  */
/*  Входни данни: Няма                                                                              */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void WaitCond(void)
{           
   CURTASK->st=Wait; /* промяна на състоянието */
   if(CURTASK->kind==Slow) /* бавна */
      whlt();  /* спира ,докато "DISP" избере нова текуща задача */
   else                                                                
   {
      READYF.eraseTask( CURTASK); /* изтрива се от списъка на готовите бързи  */
      WAIT.add(CURTASK);   /* добавяне в списъка на чакащите условие */
   }
}

/*========================================================*/
/*  WaitТаскCond: Промана  на състоянието на задача в чакаща събитие , */
/*                        посочена  от CURTASK                                                    */
/*  Входни данни: Указател към задачата,която ще се спре                                                                              */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void WaitTaskCond(TaskHandle *th)
{           
   th->st=Wait; /* промяна на състоянието  на посочената задача*/
   WAIT.add(th);  /* добавяне  в списъка на чакащите */
   if(th->kind==Slow) /* бавна */
      READYS.eraseTask( th); /* изтриване от списъка на готовите бавни */
   else                                                                
      READYF.eraseTask( th); /* изтриване от списъка на готовите бързи */
}
/*========================================================*/
/*  CurWait: Преминаване на CURTASK задача в списъка на чакащите условие  */
/*  Входни данни: Няма                                                                               */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void CurWait(void)
{                               
   if(WAIT.add(CURTASK)!=FALSE)  /* може ли да се добави в списъка на чакащите */
       READYS.eraseTask( CURTASK); /* да - изтриване от списъка на готовите бавни  */
}   

/*========================================================*/
/*  check_con:Функцията проверява за настъпили условия                          */
/*  Входни данни:Указател към паметта ,в която са подредени номерата на семафорите и */
/*     логическите връзки между тях                                                             */
/*  Изходни данни:Флаг на събитиети 0-няма,1-има                                    */
/*======================================================== */
flag check_con(void *tsk)
{
    byte k;   /* помощна променлива за резултата. */
    unsigned number=0; /* помощна променлива */
    byte *sem=tsem; /* начален адрес на таблицата със семафори */
    unsigned binput=numbls +2*(numbas +numbts);//отместване от началото на таблицата
    unsigned btime=numbls +2*numbas;//отместване от началото на таблицата
    unsigned ntime=numbls+numbas;//диапазон на номерата за семафори време
    unsigned ninput=ntime +numbts;//диапазон на номерата за семафори вход
    __asm
    {
       push ds  /* запазване на регистрите за данни ES и DS  в стека*/
       push es
       mov al,0  
       cmp WORD PTR tsk +1 ,0 /* проверка за NULL указател  на таблицата*/
       jne   l2   /* изход при ненулев указател - има таблица */
       jmp l1   /* изход при нулев указател - няма таблица */
l2:   lds di,[tsk]  /* зарежда в di адреса на условието на задачата - таблиза на задачата в паметта */
       cmp [di],0 /* проверка за край на областта с данни */
       jne l3   /* има област с данни */
       jmp l1         /* изход при нулева данна - няма условие */        
l3:   les bx,sem /* адрес на областта на семафорите */
       mov si,[di]  /* номер на първи семафор ,взето от таблицата на задачата */
       mov al,es:[bx + si] /* стойност на първи семафор */
       cmp si,ninput   /* проверка дали е семофор за вход > numbls +numbas+numbts)*/
       jg et10 /* при > е семафор -вход */
       cmp si,ntime /* проверка дали е семофор за време >= numbls +numbas и < ninput*/
       jl et2 /* не - аритметичен или логически */
       /* работа със семафор време - изчисляване на действителния адрес на семафора по номера му, */
       /* семафорите за време и аритм.сем. заемат в паметта 2 байта, за разлика от останалите ,заемащи по 1 байт  */
       mov ax,si
       sub ax,ntime /* разликата между началния и текущ номер на времевите  семафори */
       mov number,2
       mul number/* умножение по 2 -за всеки семафор са заделени 2 байта */
       add ax,btime /* прибавяне на изчисленото отместване за текущия семафор към началния семафор за време */
       mov si,ax  /* действителното отместване се записва в SI */
       mov ax,es:[bx+si] /* стойност на семафорa */
       dec ax   /* намаляване на стойноста му с 1*/
       mov es:[bx + si],ax /* обновяване на стойността му в таблицата за семафори  */
       cmp ax,0 /* изтекло ли е времето на временния семафор */
       je e6  /* да - времето е изтекло */
       mov al,0  /* не - няма събитие */
       jmp et2   /* преход към търсене на следващ операнд */
e6: 
       mov al,1  /* има събитие  - резултата е от семафор за време */            
       jmp et2   /* преход към търсене на следващ операнд */
       /* обработка на семафор - вход - четене на входа / функция на C++ / */
et10: mov number,si  /* семафор - вход */
       pop es /* подготовка за изход от асемблерския модул */
       pop ds
       push ax
       }
       k=input(number-ninput); /* прочитане на входа */
       __asm
       {           
      pop ax
      push ds /* отново вход в асемблерския модул */
      push es
      mov ds,WORD PTR tsk +2 /* инициализация на ES и DS ,понеже са загубени стойностите им */
      les bx,sem
      mov al,k /* стойноста на входа се записва в AL */

et2:  add di,2 /* указател към следващия операнд */       
       cmp [di],0 /* проверка за край на областта с данни */
       jne   l4    /* изход при ненулев указател - има таблица */
       jmp l1 /* изход при нулев указател - няма таблица */
l4:    mov cx,[di + 2] /* стойност на операнда - код на инструкцията */
       mov cs:et1,cx /* запис на посочения код на местото на операцията */
       mov si,[di] /* отместване на операнда от таблицата на семафорите */ 
       mov cl,es:[bx + si] /* стойност на операнда */
       cmp si,ninput /* проверка за  семофор вход */
       jg et20     /* преход при семафор >  - вход */
       cmp si,ntime/* проверка за  семофор- време */
       jl et1  /* не е семафор за времв */
       /* действия при семафор за време */
       push ax
       mov ax,si
       sub ax,ntime /* разликата между началния -200 и текущ номер на семафор */
       mov number,2
       mul number/* умножение по 2 -за всеки семафор са заделени 2 байта */
       add ax,btime /* прибавяне на изчисленото отместване за текущия семафор към началния семафор за време */
       mov si,ax  /* действителното отместване се записва в SI */
       pop ax
       mov cx,es:[bx+si] /* стойност на семафорa */
       cmp cx,0 //проверка дали не е изтекло времето 
       je e5  // да-  няма да се намалява
       dec cx // не - намалява се с 1
       mov es:[bx + si],cx /* стойност на операнда */
       cmp cx,0 //изтекло ли е времето
       je e5  //да 
       mov cl,0 // не - стойност 0 като резултат от наличие на събитие
       jmp et1
e5: 
      mov cl,1//* да - стойност 1 - има събитие
      jmp et1
      /* действия при семафор вход */
et20: mov number,si  /* семафор - вход */
       pop es /* подготовка за изход от асемблерския модул */
       pop ds
       push ax
       }
       k=input(number-ninput); /* прочитане на входа */
       __asm
       {           
	  pop ax
		  push ds /* отново вход в асемблерския модул */
		  push es
		  mov ds,WORD PTR tsk +2 /* инициализация на ES и DS ,понеже са загубени стойностите им */
		  les bx,sem
		  mov cl,k /* стойноста на входа се записва в AL */

et1: or al,cl  /* операция - кода и може да не е посочения */
      add di,4 /* yказател към следващия операнд и код */
      cmp [di],0 /* проверка за край на областта с данни */
       je l1                  /* изход при нулеви данни */
       jmp l4  /* зацикляне */
l1:    pop es
       pop ds
       mov k,al /* резултат */
   }                            
   return (flag )k; /* връща резултат */
}


/*========================================================*/
/*  SignalSem : Настъпва събитие -промяна на стойността на аритм. или лог.сем.*/
/*  Входни данни:Отместване от таблицата на семафорите                         */
/*  Изходни данни:Няма                                                                               */
//*======================================================== */
void SignalSem(unsigned otm)
{   
  flag old_pr=flag_pr;
  flag_pr=FALSE;
   if( otm< numbls )  /* логически семафор */
     *(tsem +otm)=1; /* установява в 1 */
   if(otm<(numbas + numbls) && otm >=numbls) /*аритметичен семафор */
    ( *(word *)(tsem + numbls  +2*(otm- numbls)))++; /* увеличава с 1 */
      flag_pr=old_pr;
}

/*========================================================*/
/*  ReadSem : Четене на семафор с посочен номер                                   */
/*  Входни данни:Отместване от таблицата на семафорите -номер на семафора  */
/*  Изходни данни:Стойност на семафора                                                                               */
//*======================================================== */
unsigned ReadSem(unsigned otm)
{ 
  flag old_pr=flag_pr;
  flag_pr=FALSE; 
  byte rez;
  unsigned rezw;
   word *tsemw=(word *)(tsem + numbls);
   if(otm <numbls) //логически
   {
      rez=(byte) *(tsem +otm);
      flag_pr=old_pr; 
     return  (byte) rez;               
   }
   if(otm>=numbls && otm<(numbls + numbas +numbts))  //аритметичен или времеви
   {
      rezw=*(tsemw +(otm - numbls));
      flag_pr=old_pr; 
       return rezw;
    }
      if(otm>=(numbls + numbas +numbts) && otm <(numbls + numbas +numbts +numbis)) //входен
      {
       rez=(byte) *(tsem +numbls +2*(numbas + numbts)+otm-(numbls + numbas +numbts));
	   flag_pr=old_pr;       
	return (byte) rez;
       }
      else
      { 
		      flag_pr=old_pr;       
	 return 0;
       }
}
					       
/*========================================================*/
/*  ТiмеSem : Настъпва събитие -промяна на стойността на семафорите за време */
/*  Входни данни:Отместване от таблицата на семафорите и стойност           */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void TimeSem(unsigned otm,unsigned value)
{           
  flag old_pr=flag_pr;
		      flag_pr=FALSE;         
  word *tsemw=(word *)(tsem+numbls +2*numbas);
   if( otm >=(numbls +numbas) && otm <=(numbls +numbas +numbts)  ) /* сем- време */
     *(tsemw +(otm- numbas - numbls))=value; /* тези семафори заемат по 2 байта от номер 200 - 400 */
			   flag_pr=old_pr;       
}

/*========================================================*/
/*  AritSem : Инициализиране  на аритметичните семафори                         */
/*  Входни данни:Отместване от таблицата на семафорите и стойност          */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void AritSem(unsigned  otm,unsigned value)
{             
   flag old_pr=flag_pr;           
			 flag_pr=FALSE;       
   if( otm >=numbls  && otm<(numbls+numbas))
     *(word *)(tsem +numbls +2*(otm -numbls))=value;
			   flag_pr=old_pr;       
}

/*========================================================*/
/*  NoSignalSem:Забрана на събитието                                                      */
/*  Входни данни:Отместване от таблицата на семафорите                         */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void NoSignalSem(unsigned otm)
{               
    flag old_pr=flag_pr;       
			flag_pr=FALSE;       
   if( otm < numbls)  /* логически семафор */
     *(tsem +otm)=0;  /* нулиране */
   if(otm< (numbas +numbls) && otm >=numbls   ) /* аритметичен семафор*/
    ( *(word *)(tsem + numbls +2*(otm -numbls)))--; /* намаляване  с 1 */
			  flag_pr=old_pr;       
}


/*========================================================*/
/*  dek:Декодира текст - условие за активност                                          */
/*  Входни данни:Текст                                                                              */
/*  Изходни данни:Указател към декодираното условие в паметта                */
/*======================================================== */
void  dek(char *str,int **ptask)
{
  char *p=str;  /* помощен указател към текста */
  int *task; /* указатели към записа на условието в паметта */
  int **rab=(int **)ptask;
  int u[10],op[9];/* u- номера на извлечените семафори от текста,op- код лог.връзки */
  char pch[5]; /* копие на  части текста в паметта - само по един номер на семафор*/
  int i=0,j=0; /* помощни променливи */
  //int len=strlen(str);      
  //pch=new char(len+1);
  while(*p)   /* докато не е достигнат края на текста-условие */
  {             
  //   *(pch+i++)=*p++; /* копиране на 1 символ от текста */
      pch[i++]=*p++;
     if(*p=='&' || *p=='|' || *p=='\0') /* следващ символ лог. операция или край на низа  ?*/
     { /* да */                  
      //      *(pch+i)='\0';/* ограничаване на низа с проветеното до тук - номер на семафор*/
	    pch[i]='\0';
	    u[j]=atoi(pch);  /* преобразуване на извлечения низ от текст в число */                
	    switch (*p) /* логическо условие  */
	    {                                                                                     
		  case '|' :  /* или */
		  op[j++]=0xc10b; /* запис на код на "или "  */
		  break;
		  case '&' : /* и */
	    op[j++]=0xc123;   /* запис на код на "и"  */
	    break;
	    case '\0' : /* край на низа */
		p--; /* връщане към предходния символ */
	    break;
       }                  

       i=0; /* нулиране на броча на символи -числа */
       p++; /* следващ символ */
    }
  }
  //delete pch;
    /* заделяне на памет за кодиране на логическото условие в паметта */
  *rab=new int[2*j +2];
  task=*rab; /* иниц. на помощен указател */
  *(task++)=u[0]; /* запис на номера на първия семафор от условието */
  for(i=1;i<=j;i++)
  {     
     *(task++)=u[i]; /* запис на номера на следващия семафор */
     *(task++)=op[i-1]; /* запис на кода на лог. връзка между семафорите */
   }
   *task=0;/* край на записа -0,инициализащия на края на областта с декодирано условие  */
}


/*========================================================*/
/*  Inicializacia: Промяна на вектора на прекъсване 0xb и настройка на таймера  */
/*  Входни данни: Няма                                                                               */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void Ini(void)
{              
       FILE  *f;               
	numbinp=7;
		f=fopen("parirq.dat","r"); //файл с име и номер на начален ред на последно изпълявания CNC файл
		if(f!=NULL)//има файл
		{
		  fscanf(f,"%u",&numbinp);//име и номер
		  fclose(f);
		}
	byte kontr=0;
	byte help=0xff;
		 help=pow(2,numbinp);//ново движение по ос X
		  kontr=0xff & ~help;       //нова стойност
   byte Attribute=0;
   double time=0;         
   byte numbv=8+numbinp;
    oldb=_dos_getvect(numbv);/* стар вектор на прекъсваане */
   _dos_setvect(numbv,DISP); /* нов вектор на прекъсване */
    Attribute=_inp(0x21) & kontr;    /* разрешено ли е прeкъсване Nо5  */
      _outp(0x21,Attribute);    /* разреши го,чрез контролера на пр.   */
    if(ReadParamMem(1045,'d',&time)!=FALSE)
	{
    unsigned br=(unsigned)(time/0.0000008);
    unsigned br1=br/10;
    }
     InTimer(0x120,10,125); /* иниц. на таймер */
}                      

/*========================================================*/
/*  whlt: Зацикляне /без действия /,докато  не падне прекъсване ,активиращо "DISP"  */
/*  Входни данни: Няма                                                                               */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void whlt(void)
{
  flag_wait=TRUE; /* флаг ЧАКАЙ -висок */
  flag_change=TRUE;
  while(flag_wait==TRUE); /* докато не стане нисък - от "DISP" */

}

/*========================================================*/
/*  InTimer: Инициализация на таймера със зададените стойности                 */
/*  Входни данни:Адрес на таймера, стойности за 0 и 1 броячи                                                 */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void InTimer(unsigned int port,unsigned int val0,unsigned int val1)
{
  unsigned rwreg=port +0x10;//регистър за четене
  unsigned kreg=port +0x3;//контролен регистър на таймера
  unsigned k1reg=port+0x1;//адрес на брояч 1
       __asm
      {   
	    mov dx,rwreg  //изчиства заявка за прекъсване или забранява прекъсване
	    mov al,0
	    out dx,al
	    jmp $+3
	    nop
	       
	       mov dx,rwreg// Забраняване на GATE 0.
	       add dx,4          
	       mov al,0xaa
	       out dx,al
	       jmp e1
	    e1:mov dx,kreg// Зареждане на контр. регистър на таймера
	      mov al,0x76// Зареждане на контр. дума. -инициализиране на брояч 1 в режим 3
	      out dx,al // Инициализация на брояч 1.
	      jmp e2
	   e2:mov dx,kreg// Зареждане на контр. регистър .
	      mov al,0x36// Зареждане на контр. дума.за брояч 0 - режим 3
	      out dx,al// Инициализация на брояч 0.
	      jmp e3     
	   e3:mov dx,k1reg// Зареждане на брояч 1.
	     mov ax,val1// Зареждане на стойност 1.
	     out dx,al// Запис на мл. и ст. байт на брояча.
	     jmp e4
	   e4:xchg al,ah
	     out dx,al 
	     jmp e5
	  e5:nop  
	    mov dx,port // Зареждане на брояч 0.
	    mov ax,val0// Зареждане на стойност 0.
	    out dx,al// Запис на мл. и ст. байт на брояча.
	    jmp e6
	 e6:xchg al,ah
	     out dx,al
	     jmp e7
	 e7:mov dx,rwreg// разрешаване  на GATE 0.
	     add dx,4
	     mov al,0x0f
	     out dx,al
	     jmp e8
	 e8:nop   
	    mov dx,rwreg// изчистване на заявка за прекъсване
	     mov al,0
	     out dx,al
	     jmp e9
	  e9:mov al,0xff //разрешаване на прекъсване
	     out dx,al
	     jmp e10
	  e10:nop
      }
}   
       extern byte activfunc;
/*****************************************************************************************/
/*Input :Функция за четене на вход ,чрез входни семафор (в тях е рзултата */
/*           от филтър 2/3 )                                                                                                 */
/* Входни данни :номер на вход                                                                               */
/* Изходни данни :стойност                                                                                      */
/*******************************************************************************************/
byte Input(unsigned numb)
{                                  
   unsigned numbsemafor=numbls+numbas +numbts +numb -1;
   byte value=0;
   value=(byte)ReadSem(numbsemafor);
   return value;
}

extern flag permission;
extern flag flag_newtime;
 void __interrupt __far DISP()
{                
   byte k=0;
    __asm      
    {
       sti
       mov dx,0x130  //изчистване на заявката за прекъсване 
       in al,dx
       mov  k,al
       mov al,0
       out dx,al
       jmp e2
  e2:mov al,0x0f  // разрешаване на прекъсването отново
       out dx,al
       jmp e3
  e3:nop
  }
  if((k & 1)!=0)
    goto et1;
  else
    goto et2;
    et1:    
     if(flag_pr==FALSE)
       goto et2;
   if(permission==FALSE)
     goto et2;
  
	     MeasTime(); /* намалява времето до изпълнението на временните задачи */
    __asm
    {
       cmp WORD PTR CURTASK,0 
       je   l1
       push ds
       push bx
       lds bx,CURTASK  
       mov ds:[bx].ucurbp,bp 
       mov ds:[bx].ucurss,ss
       pop bx
       pop ds
    l1:     
    } 
    if(CURTASK) /* ако има текуща задача */
    { 
       if(CURTASK->st==Wait)  /* трябва ли да премине в списъка на чакащите ?*/
	      CurWait(); /* да - размяна на задачата между списъците */
       if(CURTASK->st==Timed) /* трябва ли да премине в списъка на периодичните ?*/
	      CurDelay();/* да - размяна на задачата между списъците */
       flag_wait=FALSE; /* сваля се флага за изчакване с празен цикъл */
      pcurold=CURTASK;
      dprint(activpage,60,0,0x70,CURTASK->name);     
       }    
       //контрол
    FindSem(); /* проверка на условията за старт на чакащи задачи */
    if(flagend==FALSE)
      CURTASK=idle;
    else
    {  //2
		      if(flag_change==TRUE)
		      FindSlow();/* търсене на бавната задача */     
    } //else ne e IDle //2
   //контрол
      dprint(activpage,70,0,0x70,CURTASK->name);     
    __asm
    {
       cmp WORD PTR CURTASK+1,0 /* ако има нова текуща задача */
       je l2
       les bx,CURTASK           /* настройка на регистри SS и BP с нейните стойности за стек */
       mov bp,es:[bx].ucurbp
       mov ss,es:[bx].ucurss  
    l2:nop 
       nop
   }
  et2:
  __asm     mov al,20h /* и на тези с по- нисък приорит */
  __asm     out  20h,al                   

}   


void OutTimer(unsigned int port)
{
  unsigned rwreg=port +0x10;//регистър за четене
       __asm
       {
	    mov dx,rwreg
	    mov al,0 //забрана на прекъсванията 
	    out dx,al
	    jmp $+3
	    nop
	    add dx,4
	    mov al,0x0 //забрана на GATE 0
	    out dx,al
	    jmp $+3
	    nop
	}
}
