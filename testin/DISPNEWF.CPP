/******************************************************************************************/
/*                               D I S P N E W . C P P                                                 */
/*   Дефиниране на функции за работа с "DISP"  и на "DISP"                       */
/* вариянт с два източника на прекъсване пар N30  =8 (системен таймер) , друга ст. -платка "Иван" */
/* параметър 31 определя времето за прекъсване на системния таймер        */
/******************************************************************************************/
#include <dos.h>   
#include <conio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "dispnew.h"
#include "irq9new.h"          
#include "..\include\videoc.h"
#include "..\include\svga.h"
#include "string.h"   
#include "comst.h"
void (__cdecl __interrupt *oldb)();  /* вектор на прекъсване 0xb */
void (__cdecl __interrupt *old8)();  /* вектор на прекъсване 0x8 */
unsigned long brs; /* брой изпълнения */
extern List input; //списък на входовете 
flag flag_pr=TRUE;//фалг за разрешено/забранено прекъсване
char * failsafe = new char[128];//помощен низ
int numbinp;//номер на хардуерно прекъсване,използувано от "DISP"
double timed;
/***************************************************************************************/
/*  handle_program_memory_depletion: Извежда съобщение при недостиг на ОП */
/*  Входни данни : Размер на свободната памет                                                 */
/*  Изходни данни: Код на  завършване на програмата                                        */
/***************************************************************************************/
int handle_program_memory_depletion( size_t size )
{
   char buf[6]; //помощен буфер
   delete failsafe; // освобождаване на символен буфер в паметта
   dprint(0,1,1,0x70,& "Allocation failed,bytes not available " );//предупредителен текст
   UnsToStr((unsigned int)size,buf); //размер 
   dprint(0,1,2,0x70,buf ); //печат на свободната памет
   return 0;
}  

/*******************************************************************************************************/
/* TaskHandle : Създава дескриптор на задача - описание и стойности на                  */
/*                     необходимите данни                                                                          */
/* Входни данни: Име на задачата,състояние,приоритет,вид,време на периодичните  */
/*                        задачи,стек,функция,дескриптор на бавна задача,указател към       */
/*                        услловието на блокираните задачи                                                  */
/* Изходни данни:Указател към паметта с данни - дескриптор на задачата                  */
/*******************************************************************************************************/
TaskHandle*  CreateTask(char *nm,State stt,unsigned pr,Kind kn,unsigned long tm,unsigned stc,
			 TC tc,int *taskc)
{    
   TaskHandle *pth=new TaskHandle(nm,stt,pr,kn,tm,stc,tc); /*описание на задачата ,рез клас TASKHANDLE */
   switch (stt)  /* разделение по състояние */
   {
       case Current:  /* текуща */
	 	CURTASK=pth;
       break;   
       
       case Ready:  /* готова */
		 if(kn==Slow) /* бавна */
		   READYS.add(pth); /* добавяне в списъка на бавните готови задачи */
		 else
		   READYF.add(pth);  /* добавяне в списъка на бързите готови задачи */
       break;   
                              
       case Wait: /* чакаща условие */
		 WAIT.add(pth);    /* добавяне в списъка на чакащите задачи */
		 pth->taskcond=taskc; /* инициал. на условието за активност */
		 break;      
		 
       case Timed:
	 	DELAY.add(pth);   /* добавяне в списъка на периодичните задачи */
       break;    
       
       case Suspend:
		 SUSPEND.add(pth);   /* добавяне в списъка на периодичните задачи */
		 if(taskc!=NULL)
		  pth->taskcond=taskc; /* инициал. на условието за активност */ 
	       break;
     }   
     
     return pth; /* връща указател към описаната задача в паметта - обект от клас TaskHandle */
}        
    
/*******************************************************************************************************/
/* ExitSys :Изход от системата - изключва изходи,спира таймера,възстановава         */
/*              старите вектори на прекъсване  ...                                                             */
/* Входни данни:Няма                                                                                                */
/* Изходни данни :Няма                                                                                             */
/*******************************************************************************************************/
void ExitSysT(void)
{
       EndKeyb(); /* освобождава паметта от клавиатурните буфери,връща стъария вектор на кл.прек. */
       byte numbv=8+numbinp;      
       
       if(oldb !=NULL)
	      _dos_setvect(numbv,oldb);/* стр вектор на прекъсване 0xb ,използувано от "ДИСПЕЧЕРА " */      
	      
       FreeMemory(tsem);  
       
       if(EndUseFunc!=NULL)
	  	EndUseFunc();       
	  	
       SetScreenPage(0);    
       
       __asm
       {
	    mov dx,0x130
	    mov al,0
	    out dx,al
	    jmp $+3
	    nop
	  	mov dx,0x134
	    mov al,0x0
	    out dx,al
	    jmp $+3
	    nop
	}
	
	printf("END   SYSTEM  !!!");
	exit(0);
}
   
   
/*******************************************************************************************************/
/* ExitSys :Изход от системата - изключва изходи,спира таймера,възстановава         */
/*              старите вектори на прекъсване  ...                                                             */
/* Входни данни:Няма                                                                                                */
/* Изходни данни :Няма                                                                                             */
/*******************************************************************************************************/
void ExitSys8(void)
{
       EndKeyb(); /* освобождава паметта от клавиатурните буфери,връща стария вектор на кл.прек. */    
       
       byte numbv=8;         
       
       if(old8 !=NULL)
	      _dos_setvect(numbv,old8);/* стр вектор на прекъсване 0xb ,използувано от "ДИСПЕЧЕРА " */    
	      
       FreeMemory(tsem);   
       
       if(EndUseFunc!=NULL)
	  		EndUseFunc(); 
	  		
       SetScreenPage(0);   
       
       printf("END   SYSTEM  !!!");
	   exit(0);
}   

/*******************************************************************************************************/
/* EndTask :  Функцията подготвя за изход от програмата ,                                          */
/*                  извиква се от задача предизвикала изхода                                              */
/* Входни данни:Няма                                                                                                */
/* Изходни данни :Няма                                                                                             */
/*******************************************************************************************************/
void EndTask(void)
{                                                  
    TaskHandle *pcurold; /* помощна променлива за текуща задаяа */
    if(CURTASK !=NULL) /* има ли текуща задача */
   {
       pcurold=CURTASK; /* помощен указател */
    __asm
    {         
      les bx,pcurold                     //този блок търси началото на стека,който е създаден за тази задача
      mov sp,es:[bx].ubeginbp    //  В това начало е записана информациа ,чрез която може да се
      add sp,26                          // направи преход в главната програма ->изход  в DOS 
      mov bx,sp
      add bx,4
      mov bp,bx
   }
 }  
}

/*========================================================*/
/*  MeasTime:Изчисляване на оставащото до стартиране време на време    */
/*                  чакащите задачи                                                                     */
/*  Входни данни: Няма                                                                               */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void MeasTime(void)
{    
   TaskHandle *pr=NULL; // помощен указател за задача
   flag old_pr=flag_pr;
   flag_pr=FALSE;
   DELAY.cur=&DELAY.top; /* списък на време чакащи задачи */
   while(*DELAY.cur)  // има ли чакащи задачи 
  { 
      pr=(*DELAY.cur)->th;  /*  задача  с изтекло време */
      pr->timec--;  /* намаляване на времето на време чакащи задачи */
      if(pr->timec==0) /* задачи с време 0 ?*/
      {                                     
	     if(pr->kind==Slow)  /* бавни ? */
	     {
		  if(READYS.add(pr)!=FALSE) /* добавяне в списъка на бавните,ако е възможно */
		  {
			pr->st=Ready;  /* промяна на състоянието TIMED - READY */
			if(DELAY.eraseTask(pr) ==FALSE) /* изтриване от списъка на чакащите време */
			  pr->st=Timed;
	    pr->timec=pr->time; /* настройка на брояча за време */
		  }
		  else /* невъзможно да се включи в списъка на готовите - прекъснатата задача работи с паметта */
		  {   
			(*DELAY.cur)->th->timec++; /* да се провери през следващия такт */
			DELAY.cur=&(*DELAY.cur)->next; /* следваща задача */
		  }
	     }
	    else  /* остават - бързи */
	    {
	       if( READYF.add(pr)!=FALSE) /* добавяне в списъка на бързите */
	     {
			pr->st=Ready;           /* промяна на състоянието TIMED - READY */
			DELAY.eraseTask(pr); /* изтриване от списъка на чакащите време */
	       }
	       else /* невъзможно да се включи в списъка на готовите - прекъснатата задача работи с паметта */
	     {   
		   (*DELAY.cur)->th->timec++;  /* да се провери през следващия такт */
			DELAY.cur=&(*DELAY.cur)->next; /* следваща задача */
	    }
	}
	if(!*DELAY.cur) /* ако последната задача в списъка е вече в друг списък */
	    break;
     }
     else
	    DELAY.cur=&(*DELAY.cur)->next; /* следваща задача */
   }     
   flag_pr=old_pr;//връщане на старото състояние
}

/*========================================================*/
/*  StartFast:Стартиране на бързите задачи на диспечера                            */
/*  Входни данни: Няма                                                                               */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void StartFast(void)
{       
      TaskHandle *curold=NULL;  // помощен указател за задача        
      curold=CURTASK;       /* текуща задача - бавна ,запомня се*/
      READYF.cur=&READYF.top; /* списък на бързите задачи */
     
      while(*READYF.cur)  // има ли задачи в списъка 
      {                           
      	if(CURTASK->st==Timed )
	  		return;
	 	CURTASK=(*READYF.cur)->th; /* нова текуща - бърза */  
	 	CURTASK->taskcode();/* код на задачата - изпълнение */
		 if(!(*READYF.cur)) /* ако последната от списъка не е преминала в друга група */
	  		break;                                                 
		if(CURTASK == (*READYF.cur)->th)
	  		(READYF.cur) = &(*READYF.cur)->next; /* следващата задача в списъка */
      }   
      
      CURTASK=curold; /* връщане към старата CURTASK задача */
      curold=NULL;
	
}     


/*========================================================*/
/*  FindSlow:Търсене на следващата бавна задача и стартиране                  */
/*  Входни данни: Няма                                                                               */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void  FindSlow(void)
{                             
  TaskHandle *pr=NULL; //помощен указател 
  unsigned ucurpr=0; /* най - висок приоритет от разглежданите задачи */
  flag old_pr=flag_pr;
  flag_pr=FALSE;
  if(CURTASK && CURTASK->st==Current)     /* има текуща задача,започва се сравнение с нейния приоритет */
    ucurpr=CURTASK->priority; /* приоритет на текущо изпълняваната задача */
  READYS.cur=&READYS.top; /* списък на бавните задачи */
   		while(*READYS.cur)  /* докато има задачи */
	  {     
		  if((*READYS.cur)->th->priority >ucurpr) /* определяне приритета на бавната задача > от CURRENT*/
		  {
		     pr=(*READYS.cur)->th;/* кандидат за текуща задача */
		     ucurpr=pr->priority; /* нов текущ приоритет */
		  }                                              
		  (READYS.cur)=&(*READYS.cur)->next; /* следваща задача */
	   }                                                                         
    
   if(pr) /* има ли текуща - при първо извикване - няма */
   {
       if(CURTASK && CURTASK->st==Current)
	       CURTASK->st=Ready; /* промяна на състоянието  на досегашната CURRENT*/
      CURTASK=pr; /* новата CURTASK задача  групата на готовите бавни*/            
      CURTASK->st=Current; /* промяна на състоянието */
   }
   flag_pr=old_pr;
   } 

/*========================================================*/
/*  Delay: Промана  на състоянието на CURTASK задача                             */
/*  Входни данни: Няма                                                                               */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void  Delay(void)
{    
  
   if(CURTASK->kind==Slow)     /* бавна ? */
   { 
     CURTASK->st=Timed; /* промяна на състоянието в Timed*/
      whlt(); /* спира ,докато "DISP" избере нова текуща задача */
   }
   else
   {   /* бързи */
       READYF.eraseTask( CURTASK);  /* изтрива се от списъка на готовите бързи  */
       if(CURTASK->st!=Suspend)
       {               
	 CURTASK->st=Timed; /* промяна на състоянието в Timed*/
	DELAY.add(CURTASK); /* добавяне в списъка на чакащите време */
		CURTASK->timec=CURTASK->time; /* настройка на брояча за време */
		}
  }

  
}

/*========================================================*/
/*  CurDelay: Преминаване на CURTASK задача/ бавна / в спиъка на чакащите време  */
/*  Входни данни: Няма                                                                               */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void CurDelay(void)
{
   if(CURTASK->timec==0)
    CURTASK->timec=CURTASK->time; /* настройка на брояча за време */
   if(READYS.eraseTask( CURTASK)!=FALSE) /* изтриване ит списъка на готовите бавни */
     DELAY.add(CURTASK);/* добавяне в списъка на чакащите време */
}

/*========================================================*/
/*  NewSuspend: Промяна  на състоянието на указаната задача във SUSPEND */
/*                             (временно неактивна  )                                               */
/*  Входни данни: Указател към задачата                                                                         */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void  NewSuspend(TaskHandle *pth)
{                        
   if(pth==NULL)//празен указтел
     return;//връщане             
   if(pth->st==Suspend)//ако вече се намира в списъка на неактивните задачи
     return;//връщане
     
  flag old_pr=flag_pr;//запазване състоянието на флага  
  flag_pr=FALSE;//забранено прекъсване
    SUSPEND.add(pth); //запис в списъка на неактивните задачи                           
    //търсене в списъците
    READYF.cur=&READYF.top;//спъсък на готовите задача
    READYF.find(pth);  //търсене в списъка на готовите
    if(*READYF.cur)//намерена е задачата
       READYF.eraseTask(pth);//изтриване
    else//няма я в този списък
    {
       DELAY.cur=&DELAY.top;//списък на периодичните
       DELAY.find(pth);//търсене
       if(*DELAY.cur)//намерена е
			DELAY.eraseTask(pth);//изтриване
       else//няма я в този списък
       {   
			WAIT.cur=&WAIT.top;//търсене в списъкс на чакащите
			WAIT.find(pth);//търсене
			if(*WAIT.cur)//намерена е
			WAIT.eraseTask(pth);     //изтриване
			else//няма я в този списък
			{
			     READYS.cur=&READYS.top;//търсене в списъка на бързите
				 READYS.find(pth);  //търсене в списъка на готовите-бързи
				if(*READYS.cur)//има 
					READYS.eraseTask(pth);//изтриване
			}
       }
    }
    if(pth!=NULL)//има задача
    {
	if(pth->st==Current)//състоянив -текущо изпълнявана?
	{  //да
	       pth->st=Suspend; //състояние-неактивна
		   flag_change=TRUE;//може да се извика друга задача за изпълнение
		   flag_pr=old_pr;//връщане на състоянието на фалга за прекъсване
		   whlt();//изчакване активиране на "DISP" за избор на нова задача
	}
	else//не е текущо изпълнявана
		pth->st=Suspend;  //състояние-неактивна
		flag_pr=old_pr;//връщане на състоянието на фалга за прекъсване
    }
}

/*========================================================*/
/*  Resume: Промяна  на състоянието на указаната задача от SUSPEND */
/*                             (временно неактивна  )  търсено предходно                           */
/*  Входни данни: Указател към задачата                                            */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void  Resume(TaskHandle *pth)
{    
   flag old_pr=flag_pr;    //запазване състоянието на флага  
    flag_pr=FALSE;//забранено прекъсване
    SUSPEND.cur=&SUSPEND.top;//списък на неактивните задачи
    SUSPEND.find(pth);//търсене
    if(!*SUSPEND.cur)//няма задача
    {
      flag_pr=old_pr;//връщане на състоянието на фалга за прекъсване
      return;//връщане
    }
    if(pth->taskcond!=NULL)//има условие за активност
    {
       WAIT.add(pth); //търсене в списъка на чакащите
       pth->st=Wait;//смяна на състоянието от неактивна -чакаща
    }
    else//няма условие за активност
    {
      if(pth->time!=0  && pth->timec!=0)//периодична?
      {//да
		DELAY.add(pth);//търсене в списъка на периодичните
		pth->st=Timed;//промяна на състоянието от неактивна -периодична
       }
       else//не е периодична
       {
			READYS.add(pth);//добавяне  в списъка на готовите
			pth->st=Ready;//промяна на състоянието от неактивна -готова
	}
      }
      SUSPEND.eraseTask(pth);//изтриване от списъка на неактивните
      flag_pr=old_pr;//връщане на състоянието на фалга за прекъсване
}

/*========================================================*/
/*  FindSem : Проверка за настъпване на събитията ,очаквани от дадени задачи */
/*  Входни данни: Няма                                                                               */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void FindSem(void)
{    
   TaskHandle *pth=NULL;// помощен указател
   flag old_pr=flag_pr;
   flag_pr=FALSE;
   WAIT.cur=&WAIT.top; /* иниц. на текущия указател от списъка на чакащите */
   while(*WAIT.cur)  /* обхогдане на списъка от  чакащи задачи */ 
   {
       pth=(*WAIT.cur)->th; /* иниц. на помощния указател с разглежданата задача */
       if(check_con(pth->taskcond)!=FALSE ) /* проверка дали е настъпило събитието */
       {    /* да */
	    if(pth->kind==Slow)  /* бавни ? */
	    {
	    if( READYS.add(pth)!=FALSE)              /* добавяне в списъка на бавните */
	    {   
	       WAIT.eraseTask(pth); /* изтриване от списъка на чакащите условие*/
			pth->st=Ready; /*промяна на  състовнието- READY */
	      }
	      else /* невъзможхост за добавяне - работи се с паметта */
	       WAIT.cur=&(*WAIT.cur)->next; /* следваща задача */
       }
	 else  /* остават - бързи */
	 {
	     if( READYF.add(pth)!=FALSE) /* добавяне в списъка на бързите */
	    {   
	       WAIT.eraseTask(pth); /* изтриване от списъка на чакащите условие*/
			pth->st=Ready; /* задачата е в състовние READY */
	      }
	      else /* невъзможхост за добавяне - работи се с паметта */
		  WAIT.cur=&(*WAIT.cur)->next;  /* следваща задача */
	 }  
	 if(!*WAIT.cur) /* последна задача в списъка */
	    break;           
     }
     else
       WAIT.cur=&(*WAIT.cur)->next;/* следваща задача */
   }     
   flag_pr=old_pr;
}

/*========================================================*/
/*  WaitCond: Промана  на състоянието на CURTASK задача в чакаща събитие  */
/*  Входни данни: Няма                                                                              */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void WaitCond(void)
{           
   CURTASK->st=Wait; /* промяна на състоянието */
   if(CURTASK->kind==Slow) /* бавна */
      whlt();  /* спира ,докато "DISP" избере нова текуща задача */
   else                                                                
   {
      READYF.eraseTask( CURTASK); /* изтрива се от списъка на готовите бързи  */
      WAIT.add(CURTASK);   /* добавяне в списъка на чакащите условие */
   }
}

/*========================================================*/
/*  WaitТаскCond: Промана  на състоянието на задача в чакаща събитие , */
/*                        посочена  от CURTASK                                                    */
/*  Входни данни: Указател към задачата,която ще се спре                                                                              */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void WaitTaskCond(TaskHandle *th)
{           
   th->st=Wait; /* промяна на състоянието  на посочената задача*/
   WAIT.add(th);  /* добавяне в списъка на чакащите */
   if(th->kind==Slow) /* бавна */
      READYS.eraseTask( th); /* изтриване от списъка на готовите бавни */
   else                                                                
      READYF.eraseTask( th); /* изтриване от списъка на готовите бързи */
}
/*========================================================*/
/*  CurWait: Преминаване на CURTASK задача в списъка на чакащите условие  */
/*  Входни данни: Няма                                                                               */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void CurWait(void)
{                               
   if(WAIT.add(CURTASK)!=FALSE)  /* може ли да се добави в списъка на чакащите */
       READYS.eraseTask( CURTASK); /* да - изтриване от списъка на готовите бавни  */
}   

/*========================================================*/
/*  check_con:Функцията проверява за настъпили условия                          */
/*  Входни данни:Указател към паметта ,в която са подредени номерата на семафорите и */
/*     логическите връзки между тях                                                             */
/*  Изходни данни:Флаг на събитиети 0-няма,1-има                                    */
/*======================================================== */
flag check_con(void *tsk)
{
    byte k;   /* помощна променлива за резултата. */
    unsigned number=0; /* помощна променлива */
    byte *sem=tsem; /* начален адрес на таблицата със семафори */
    unsigned binput=numbls +2*(numbas +numbts);//отместване от началото на таблицата
    unsigned btime=numbls +2*numbas;//отместване от началото на таблицата
    unsigned ntime=numbls+numbas;//диапазон на номерата за семафори време
    unsigned ninput=ntime +numbts;//диапазон на номерата за семафори вход
    __asm
    {
       push ds  /* запазване на регистрите за данни ES и DS  в стека*/
       push es
       mov al,0  
       cmp WORD PTR tsk +1 ,0 /* проверка за NULL указател  на таблицата*/
       jne   l2   /* изход при ненулев указател - има таблица */
       jmp l1   /* изход при нулев указател - няма таблица */
l2:   lds di,[tsk]  /* зарежда в di адреса на условието на задачата - таблиза на задачата в паметта */
       cmp [di],0 /* проверка за край на областта с данни */
       jne l3   /* има област с данни */
       jmp l1         /* изход при нулева данна - няма условие */        
l3:   les bx,sem /* адрес на областта на семафорите */
       mov si,[di]  /* номер на първи семафор ,взето от таблицата на задачата */
       mov al,es:[bx + si] /* стойност на първи семафор */
       cmp si,ninput   /* проверка дали е семофор за вход > numbls +numbas+numbts)*/
       jg et10 /* при > е семафор -вход */
       cmp si,ntime /* проверка дали е семофор за време >= numbls +numbas и < ninput*/
       jl et2 /* не - аритметичен или логически */
       /* работа със семафор време - изчисляване на действителния адрес на семафора по номера му, */
       /* семафорите за време и аритм.сем. заемат в паметта 2 байта, за разлика от останалите ,заемащи по 1 байт  */
       mov ax,si
       sub ax,ntime /* разликата между началния и текущ номер на времевите  семафори */
       mov number,2
       mul number/* умножение по 2 -за всеки семафор са заделени 2 байта */
       add ax,btime /* прибавяне на изчисленото отместване за текущия семафор към началния семафор за време */
       mov si,ax  /* действителното отместване се записва в SI */
       mov ax,es:[bx+si] /* стойност на семафорa */
       dec ax   /* намаляване на стойноста му с 1*/
       mov es:[bx + si],ax /* обновяване на стойността му в таблицата за семафори  */
       cmp ax,0 /* изтекло ли е времето на временния семафор */
       je e6  /* да - времето е изтекло */
       mov al,0  /* не - няма събитие */
       jmp et2   /* преход към търсене на следващ операнд */
e6: 
       mov al,1  /* има събитие  - резултата е от семафор за време */            
       jmp et2   /* преход към търсене на следващ операнд */
       /* обработка на семафор - вход - четене на входа / функция на C++ / */
et10: mov number,si  /* семафор - вход */
       pop es /* подготовка за изход от асемблерския модул */
       pop ds
       push ax
       }
       k=input(number-ninput); /* прочитане на входа */
       __asm
       {           
      pop ax
      push ds /* отново вход в асемблерския модул */
      push es
      mov ds,WORD PTR tsk +2 /* инициализация на ES и DS ,понеже са загубени стойностите им */
      les bx,sem
      mov al,k /* стойноста на входа се записва в AL */

et2:  add di,2 /* указател към следващия операнд */       
       cmp [di],0 /* проверка за край на областта с данни */
       jne   l4    /* изход при ненулев указател - има таблица */
       jmp l1 /* изход при нулев указател - няма таблица */
l4:    mov cx,[di + 2] /* стойност на операнда - код на инструкцията */
       mov cs:et1,cx /* запис на посочения код на местото на операцията */
       mov si,[di] /* отместване на операнда от таблицата на семафорите */ 
       mov cl,es:[bx + si] /* стойност на операнда */
       cmp si,ninput /* проверка за  семофор вход */
       jg et20     /* преход при семафор >  - вход */
       cmp si,ntime/* проверка за  семофор- време */
       jl et1  /* не е семафор за времв */
       /* действия при семафор за време */
       push ax
       mov ax,si
       sub ax,ntime /* разликата между началния -200 и текущ номер на семафор */
       mov number,2
       mul number/* умножение по 2 -за всеки семафор са заделени 2 байта */
       add ax,btime /* прибавяне на изчисленото отместване за текущия семафор към началния семафор за време */
       mov si,ax  /* действителното отместване се записва в SI */
       pop ax
       mov cx,es:[bx+si] /* стойност на семафорa */
       cmp cx,0 //проверка дали не е изтекло времето 
       je e5  // да-  няма да се намалява
       dec cx // не - намалява се с 1
       mov es:[bx + si],cx /* стойност на операнда */
       cmp cx,0 //изтекло ли е времето
       je e5  //да 
       mov cl,0 // не - стойност 0 като резултат от наличие на събитие
       jmp et1
e5: 
      mov cl,1//* да - стойност 1 - има събитие
      jmp et1
      /* действия при семафор вход */
et20: mov number,si  /* семафор - вход */
       pop es /* подготовка за изход от асемблерския модул */
       pop ds
       push ax
       }
       k=input(number-ninput); /* прочитане на входа */
       __asm
       {           
	  pop ax
		  push ds /* отново вход в асемблерския модул */
		  push es
		  mov ds,WORD PTR tsk +2 /* инициализация на ES и DS ,понеже са загубени стойностите им */
		  les bx,sem
		  mov cl,k /* стойноста на входа се записва в AL */

et1: or al,cl  /* операция - кода и може да не е посочения */
      add di,4 /* yказател към следващия операнд и код */
      cmp [di],0 /* проверка за край на областта с данни */
       je l1                  /* изход при нулеви данни */
       jmp l4  /* зацикляне */
l1:    pop es
       pop ds
       mov k,al /* резултат */
   }                            
   return (flag )k; /* връща резултат */
}


/*========================================================*/
/*  SignalSem : Настъпва събитие -промяна на стойността на аритм. или лог.сем.*/
/*  Входни данни:Отместване от таблицата на семафорите                         */
/*  Изходни данни:Няма                                                                               */
//*======================================================== */
void SignalSem(unsigned otm)
{   
  flag old_pr=flag_pr;
  flag_pr=FALSE;
   if( otm< numbls )  /* логически семафор */
     *(tsem +otm)=1; /* установява в 1 */
   if(otm<(numbas + numbls) && otm >=numbls) /*аритметичен семафор */
    ( *(word *)(tsem + numbls  +2*(otm- numbls)))++; /* увеличава с 1 */
      flag_pr=old_pr;
}

/*========================================================*/
/*  ReadSem : Четене на семафор с посочен номер                                   */
/*  Входни данни:Отместване от таблицата на семафорите -номер на семафора  */
/*  Изходни данни:Стойност на семафора                                                                               */
//*======================================================== */
unsigned ReadSem(unsigned otm)
{ 
  flag old_pr=flag_pr;
  flag_pr=FALSE; 
  byte rez;
  unsigned rezw;
   word *tsemw=(word *)(tsem + numbls);
   if(otm <numbls) //логически
   {
      rez=(byte) *(tsem +otm);
      flag_pr=old_pr; 
     return  (byte) rez;               
   }
   if(otm>=numbls && otm<(numbls + numbas +numbts))  //аритметичен или времеви
   {
      rezw=*(tsemw +(otm - numbls));
      flag_pr=old_pr; 
       return rezw;
    }
      if(otm>=(numbls + numbas +numbts) && otm <(numbls + numbas +numbts +numbis)) //входен
      {
       rez=(byte) *(tsem +numbls +2*(numbas + numbts)+otm-(numbls + numbas +numbts));
	   flag_pr=old_pr;       
	return (byte) rez;
       }
      else
      { 
		      flag_pr=old_pr;       
	 return 0;
       }
}
					       
/*========================================================*/
/*  ТiмеSem : Настъпва събитие -промяна на стойността на семафорите за време */
/*  Входни данни:Отместване от таблицата на семафорите и стойност           */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void TimeSem(unsigned otm,unsigned value)
{           
  flag old_pr=flag_pr;
		      flag_pr=FALSE;         
  word *tsemw=(word *)(tsem+numbls +2*numbas);
   if( otm >=(numbls +numbas) && otm <=(numbls +numbas +numbts)  ) /* сем- време */
     *(tsemw +(otm- numbas - numbls))=value; /* тези семафори заемат по 2 байта от номер 200 - 400 */
			   flag_pr=old_pr;       
}

/*========================================================*/
/*  AritSem : Инициализиране  на аритметичните семафори                         */
/*  Входни данни:Отместване от таблицата на семафорите и стойност          */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void AritSem(unsigned  otm,unsigned value)
{             
   flag old_pr=flag_pr;           
			 flag_pr=FALSE;       
   if( otm >=numbls  && otm<(numbls+numbas))
     *(word *)(tsem +numbls +2*(otm -numbls))=value;
			   flag_pr=old_pr;       
}

/*========================================================*/
/*  NoSignalSem:Забрана на събитието                                                      */
/*  Входни данни:Отместване от таблицата на семафорите                         */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void NoSignalSem(unsigned otm)
{               
    flag old_pr=flag_pr;       
			flag_pr=FALSE;       
   if( otm < numbls)  /* логически семафор */
     *(tsem +otm)=0;  /* нулиране */
   if(otm< (numbas +numbls) && otm >=numbls   ) /* аритметичен семафор*/
    ( *(word *)(tsem + numbls +2*(otm -numbls)))--; /* намаляване  с 1 */
			  flag_pr=old_pr;       
}


/*========================================================*/
/*  dek:Декодира текст - условие за активност                                          */
/*  Входни данни:Текст                                                                              */
/*  Изходни данни:Указател към декодираното условие в паметта                */
/*======================================================== */
void  dek(char *str,int **ptask)
{
  char *p=str;  /* помощен указател към текста */
  int *task; /* указатели към записа на условието в паметта */
  int **rab=(int **)ptask;
  int u[10],op[9];/* u- номера на извлечените семафори от текста,op- код лог.връзки */
  char pch[5]; /* копие на  части текста в паметта - само по един номер на семафор*/
  int i=0,j=0; /* помощни променливи */
  //int len=strlen(str);      
  //pch=new char(len+1);
  while(*p)   /* докато не е достигнат края на текста-условие */
  {             
  //   *(pch+i++)=*p++; /* копиране на 1 символ от текста */
      pch[i++]=*p++;
     if(*p=='&' || *p=='|' || *p=='\0') /* следващ символ лог. операция или край на низа  ?*/
     { /* да */                  
      //      *(pch+i)='\0';/* ограничаване на низа с проветеното до тук - номер на семафор*/
	    pch[i]='\0';
	    u[j]=atoi(pch);  /* преобразуване на извлечения низ от текст в число */                
	    switch (*p) /* логическо условие  */
	    {                                                                                     
		  case '|' :  /* или */
		  op[j++]=0xc10b; /* запис на код на "или "  */
		  break;
		  case '&' : /* и */
	    op[j++]=0xc123;   /* запис на код на "и"  */
	    break;
	    case '\0' : /* край на низа */
		p--; /* връщане към предходния символ */
	    break;
       }                  

       i=0; /* нулиране на броча на символи -числа */
       p++; /* следващ символ */
    }
  }
  //delete pch;
    /* заделяне на памет за кодиране на логическото условие в паметта */
  *rab=new int[2*j +2];
  task=*rab; /* иниц. на помощен указател */
  *(task++)=u[0]; /* запис на номера на първия семафор от условието */
  for(i=1;i<=j;i++)
  {     
     *(task++)=u[i]; /* запис на номера на следващия семафор */
     *(task++)=op[i-1]; /* запис на кода на лог. връзка между семафорите */
   }
   *task=0;/* край на записа -0,инициализащия на края на областта с декодирано условие  */
}
void IniV(void)
{
if(ReadParamMem(1044,'i',&numbinp)==FALSE)
	     AritSem(1003,1);       
    if(ReadParamMem(1045,'d',&timed)==FALSE)
	     AritSem(1003,1);
		 
}
/*========================================================*/
/*  Inicializacia: Промяна на вектора на прекъсване 0xb и настройка на таймера  */
/*  Входни данни: Няма                                                                               */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void IniT(void)
{                        
      byte kontr=0;
      byte help=0xff;
      help=byte(pow(2,numbinp));//
      kontr=0xff & ~help;       //нова стойност
      byte Attribute=0;
	  byte numbv=8+numbinp;
      oldb=_dos_getvect(numbv);/* стар вектор на прекъсваане */
      _dos_setvect(numbv,DISPT); /* нов вектор на прекъсване */
      Attribute=_inp(0x21) & kontr;    /* разрешено ли е прeкъсване Nо5  */
     _outp(0x21,Attribute);    /* разреши го,чрез контролера на пр.   */
     double time=timed;     
     unsigned br=(unsigned)(time/0.0000008);
     unsigned br1=br/10;
     InTimer(0x120,10,125); /* иниц. на таймер */
}                      
    
/*========================================================*/
/*  IniTm: Промяна на вектора на прекъсване 0x8 и настройка на таймера  */
/*  Входни данни: Стойност , зареждана в таймера , време за прекъсвания  */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void Ini8(void)
{                        
       unsigned countdown ;  
       if(ReadParamMem(31,'i',&countdown)==FALSE)//брoй семафори-входове>ЗАБ: да се сложи действителен номер на параметър
     	countdown=1193;       //тази стойност е за 1милисекунда (1193180 / 1193=1000 пъти в секунда
        __asm
        {

			cli
	   	    mov	al,00110100b  // bit 7,6 = (00) timer counter 0
			   				            // bit 5,4 = (11) write LSB then MSB
			     						// bit 3-1 = (000
			      					   //; bit 0 = (0) binary counter
	  		 out	43h,al	      //prep PIT, counter 0, square wave&init count
	   	 	 mov	cx,countdown 
	  		 mov	al,cl	     
	  		 out	40h,al
	  		 mov	al,ch	     
	  	     out	40h,al
	 	     sti
           }                
          
		byte numbv=8;   //номер на вектора на прекъсване , обслужващо системния таймер
    	old8=_dos_getvect(numbv);/* стар вектор на прекъсваане */
   		_dos_setvect(numbv,DISP8); /* нов вектор на прекъсване */
}                          
    
/*========================================================*/
/*  whlt: Зацикляне /без действия /,докато  не падне прекъсване ,активиращо "DISP"  */
/*  Входни данни: Няма                                                                               */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void whlt(void)
{
  flag_wait=TRUE; /* флаг ЧАКАЙ -висок */
  flag_change=TRUE;
  while(flag_wait==TRUE); /* докато не стане нисък - от "DISP" */

}

/*========================================================*/
/*  InTimer: Инициализация на таймера със зададените стойности                 */
/*  Входни данни:Адрес на таймера, стойности за 0 и 1 броячи                                                 */
/*  Изходни данни:Няма                                                                               */
/*======================================================== */
void InTimer(unsigned int port,unsigned int val0,unsigned int val1)
{
  unsigned rwreg=port +0x10;//регистър за четене
  unsigned kreg=port +0x3;//контролен регистър на таймера
  unsigned k1reg=port+0x1;//адрес на брояч 1
       __asm
      {   
	    mov dx,rwreg  //изчиства заявка за прекъсване или забранява прекъсване
	    mov al,0
	    out dx,al
	    jmp $+3
	    nop
	       
	       mov dx,rwreg// Забраняване на GATE 0.
	       add dx,4          
	       mov al,0xaa
	       out dx,al
	       jmp e1
	    e1:mov dx,kreg// Зареждане на контр. регистър на таймера
	      mov al,0x76// Зареждане на контр. дума. -инициализиране на брояч 1 в режим 3
	      out dx,al // Инициализация на брояч 1.
	      jmp e2
	   e2:mov dx,kreg// Зареждане на контр. регистър .
	      mov al,0x36// Зареждане на контр. дума.за брояч 0 - режим 3
	      out dx,al// Инициализация на брояч 0.
	      jmp e3     
	   e3:mov dx,k1reg// Зареждане на брояч 1.
	     mov ax,val1// Зареждане на стойност 1.
	     out dx,al// Запис на мл. и ст. байт на брояча.
	     jmp e4
	   e4:xchg al,ah
	     out dx,al 
	     jmp e5
	  e5:nop  
	    mov dx,port // Зареждане на брояч 0.
	    mov ax,val0// Зареждане на стойност 0.
	    out dx,al// Запис на мл. и ст. байт на брояча.
	    jmp e6
	 e6:xchg al,ah
	     out dx,al
	     jmp e7
	 e7:mov dx,rwreg// разрешаване  на GATE 0.
	     add dx,4
	     mov al,0x0f
	     out dx,al
	     jmp e8
	 e8:nop   
	    mov dx,rwreg// изчистване на заявка за прекъсване
	     mov al,0
	     out dx,al
	     jmp e9
	  e9:mov al,0xff //разрешаване на прекъсване
	     out dx,al
	     jmp e10
	  e10:nop
      }
}   
       extern byte activfunc;
/*****************************************************************************************/
/*Input :Функция за четене на вход ,чрез входни семафор (в тях е рзултата */
/*           от филтър 2/3 )                                                                                                 */
/* Входни данни :номер на вход                                                                               */
/* Изходни данни :стойност                                                                                      */
/*******************************************************************************************/
byte Input(unsigned numb)
{                                  
   unsigned numbsemafor=numbls+numbas +numbts +numb -1;//номер на семафора
   byte value=0;
   value=(byte)ReadSem(numbsemafor);//ветене на семафора
   return value;
}
   unsigned brread;
   extern unsigned brk1;
extern flag permission;  //флаг за заетост от функциии за работо с паметта
/****************************************************************************************************/
/* DISP: Функция на задача "DISP". Работи на прекъсване от таймер.                  */
/*              Ако има подходящи условия, превключва задачите ,като избира измежду */
/*             готовите -тази с най-висок приоритет .Намалява времето до изпълне- */
/*             нието на периодичните задачи.Проверява условята за активност на */
/*             чакащите задачи.Изпълнява готови бързи задачи    .                                       */
/* Входни данни:Няма                                                                                                                                */
/*Изходни данни :Няма                                                                                                                              */
/****************************************************************************************************/
 void __interrupt __far DISPT()
{                
   byte k=0;
    __asm      
    {
      sti//разрешени са прекъсвания
       mov dx,0x130  //изчистване на заявката за прекъсване 
       in al,dx
       mov  k,al
       mov al,0
       out dx,al
       jmp e2
  e2:mov al,0x0f  // разрешаване на прекъсването отново
       out dx,al
       jmp e3
  e3:nop
  }              

  if((k & 1)!=0)//чаканото прекъсване ?
    goto et1;//да
  else//друго прекъсване
    goto et2;//преход в края
    et1:    //обработка на прекъсването
     if(flag_pr==FALSE)//забранено ли е прекъсване ?
       goto et2;//да -преход в края
   if(permission==FALSE)//има ли работа с паметта-заделяне или освобождаване
     goto et2;//да -преход в края
     
     MeasTime(); /* намалява времето до изпълнението на временните задачи */
     if(CURTASK!=NULL && CURTASK->st==Ready && CURTASK->time!=0 && CURTASK->timec>0)//ако е периодична
	    CURTASK->timec--;// започва намаляване на времето,докато се изпълнява
	 StartFast();//изпълнение на бързи задачи              
	       FindSem(); /* проверка на условията за старт на чакащи задачи */
    if(flag_change==FALSE)//може ли да се смени задачата?
	       goto et2;//не- преход в края
    __asm
    {
       cmp WORD PTR CURTASK,0 //текуща задача
       je   l1
       push ds
       push bx
       lds bx,CURTASK  //извличане на адреса на обекта
       mov ds:[bx].ucurbp,bp //запазване състоянието на регистър bp
       mov ds:[bx].ucurss,ss//запазване състоянието на регистър ss
       pop bx
       pop ds
    l1:
    } 
    if(CURTASK) /* ако има текуща задача */
    { 
       if(CURTASK->st==Wait)  /* трябва ли да премине в списъка на чакащите ?*/
	      CurWait(); /* да - размяна на задачата между списъците */
       if(CURTASK->st==Timed) /* трябва ли да премине в списъка на периодичните ?*/
	      CurDelay();/* да - размяна на задачата между списъците */
       flag_wait=FALSE; /* сваля се флага за изчакване с празен цикъл */
      dprint(activpage,60,0,0x70,CURTASK->name);     //тест-дисплей на името
       }    
      if(flagend==FALSE)//изход?
	      CURTASK=idle;//да-преход ким празната задача "IDLE"
    else//не
		      FindSlow();/*да- търсене на бавната задача */     
   //контрол
	dprint(activpage,70,0,0x70,CURTASK->name);     //тест-дисплей на новата задача
//              char buffer[10];          
//              brk1=ReadSem(1018);
//    UnsToStr((unsigned int)brk1,buffer);   
//       dprint(activpage,65,1,0x70,buffer);    

    __asm
    { 
       cmp WORD PTR CURTASK+1,0 /* ако има нова текуща задача */
       je l2
       les bx,CURTASK           /* настройка на регистри SS и BP с нейните стойности за стек */
       mov bp,es:[bx].ucurbp//зареждане на регистър bp със съхранената му стойност ,преди смяна
       mov ss,es:[bx].ucurss  //зареждане на регистър bp със съхранената му стойност,преди смяна
       mov sp,bp
    l2:nop 
       nop
   }
  et2:      
     
	__asm sti;
  __asm     mov al,20h /* и на тези с по- нисък приорит */
  __asm     out  20h,al                   

}   



/****************************************************************************************************/
/* DISP: Функция на задача "DISP". Работи на прекъсване от  системния таймер.                  */
/*              Ако има подходящи условия, превключва задачите ,като избира измежду */
/*             готовите -тази с най-висок приоритет .Намалява времето до изпълне- */
/*             нието на периодичните задачи.Проверява условята за активност на */
/*             чакащите задачи.Изпълнява готови бързи задачи    .                                       */
/* Входни данни:Няма                                                                                                                                */
/*Изходни данни :Няма                                                                                                                              */
/****************************************************************************************************/
 void __interrupt __far DISP8()
{
    
     if(flag_pr==FALSE)//забранено ли е прекъсване ?
       goto et2;//да -преход в края
     if(permission==FALSE)//има ли работа с паметта-заделяне или освобождаване
       goto et2;//да -преход в края
     
     MeasTime(); /* намалява времето до изпълнението на временните задачи */
     if(CURTASK!=NULL && CURTASK->st==Ready && CURTASK->time!=0 && CURTASK->timec>0)//ако е периодична
	    CURTASK->timec--;// започва намаляване на времето,докато се изпълнява
	 StartFast();//изпълнение на бързи задачи              
	       FindSem(); /* проверка на условията за старт на чакащи задачи */
    if(flag_change==FALSE)//може ли да се смени задачата?
	       goto et2;//не- преход в края
    __asm
    {
       cmp WORD PTR CURTASK,0 //текуща задача
       je   l1
       push ds
       push bx
       lds bx,CURTASK  //извличане на адреса на обекта
       mov ds:[bx].ucurbp,bp //запазване състоянието на регистър bp
       mov ds:[bx].ucurss,ss//запазване състоянието на регистър ss
       pop bx
       pop ds
    l1:
    } 
    if(CURTASK) /* ако има текуща задача */
    { 
       if(CURTASK->st==Wait)  /* трябва ли да премине в списъка на чакащите ?*/
	      CurWait(); /* да - размяна на задачата между списъците */
       if(CURTASK->st==Timed) /* трябва ли да премине в списъка на периодичните ?*/
	      CurDelay();/* да - размяна на задачата между списъците */
       flag_wait=FALSE; /* сваля се флага за изчакване с празен цикъл */
      //dprint(activpage,60,0,0x70,CURTASK->name);     //тест-дисплей на името
       }    
      if(flagend==FALSE)//изход?
	      CURTASK=idle;//да-преход ким празната задача "IDLE"
    else//не
		      FindSlow();/*да- търсене на бавната задача */     
   //контрол
	//dprint(activpage,70,0,0x70,CURTASK->name);     //тест-дисплей на новата задача
	
    
    __asm
    { 
       cmp WORD PTR CURTASK+1,0 /* ако има нова текуща задача */
       je l2
       les bx,CURTASK           /* настройка на регистри SS и BP с нейните стойности за стек */
       mov bp,es:[bx].ucurbp//зареждане на регистър bp със съхранената му стойност ,преди смяна
       mov ss,es:[bx].ucurss  //зареждане на регистър bp със съхранената му стойност,преди смяна
       mov sp,bp
    l2:nop 
       nop
   }
  et2:      
      
	__asm sti;
    __asm     mov al,20h /* и на тези с по- нисък приорит */
    __asm     out  20h,al                   

}   



